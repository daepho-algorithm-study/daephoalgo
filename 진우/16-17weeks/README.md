# 이번주 풀이 문제🧩

| 번호 | 문제 | 번호 | 문제 | 번호 | 문제 | 번호 | 문제 |
|:--:|:--|:--:|:--|:--:|:--|:--:|:--|
| **1** | [별 찍기 - 10 - 2447](https://www.acmicpc.net/problem/2447) | **2** | [스도쿠 - 2580](https://www.acmicpc.net/problem/2580) | **3** | [칸토어 집합 - 4779](https://www.acmicpc.net/problem/4779) | **4** | [N-Queen - 9663](https://www.acmicpc.net/problem/9663) |
| **5** | [피보나치 수 5 - 10870](https://www.acmicpc.net/problem/10870) | **6** | [하노이 탑 이동 순서 - 11729](https://www.acmicpc.net/problem/11729) | **7** | [연산자 끼워넣기 - 14888](https://www.acmicpc.net/problem/14888) | **8** | [스타트와 링크 - 14889 ](https://www.acmicpc.net/problem/14889) |
| **9** | [N과 M (1) - 15649](https://www.acmicpc.net/problem/15649) | **10** | [N과 M (2) - 15650](https://www.acmicpc.net/problem/15650) | **11** | [N과 M (3) - 15651](https://www.acmicpc.net/problem/15651) | **12** | [N과 M (4) - 15652](https://www.acmicpc.net/problem/15652)|
| **13** | [병합 정렬 1 - 24060](https://www.acmicpc.net/problem/24060)| **14** | [재귀의 귀재 - 25501](https://www.acmicpc.net/problem/25501)| |

---

# 🧩 문제

## [별 찍기 - 10 - 2447](https://www.acmicpc.net/problem/2447)

### 💡 아이디어 / 접근법
N = 3일 경우
비어있는 좌표는 (1,1) , (1,4) , (1,7) , (1,10) , ... , (1, 25)이다.
따라서 가장 기본적인 단위에서의 규칙을 만족시키기 위한 조건은
i%3 == 1 && j%3 == 1 이다.

N = 9 일 경우,
이 때 비어있는 가운데 좌표는, (3,3) (3,4) (3,5) (4,3) (4,4) (4,5) (5,3) (5,4) (5,5) 이다.
이를 수식으로 표현하면, 3x3의 기본단위 모형이 한개 나온 후, 비어있다는 표현이므로
(i / 3) % 3 == 1 && (j / 3 ) % 3 == 1의 조건을 만족시키면 된다.


### 🤔 후기
규칙을 생각하는게 어려워서 결국 힌트와 정답을 보고 어떻게 동작 되는지 이해했다.
 
---

# 🧩 문제

## [스도쿠 - 2580](https://www.acmicpc.net/problem/2580)

### 💡 아이디어 / 접근법
먼저 빈 칸들의 좌표를 배열에 저장하고, 각 빈 칸에 1부터 9까지의 숫자를 대입하며 유효성을 검사한다.
같은 행, 같은 열, 그리고 3x3 박스 내에 중복되는 숫자가 없는지를 확인
모든 빈 칸을 채우면 완성된 스도쿠를 출력하고 프로그램을 즉시 종료(정답이 여러개일 경우에도 1개만 출력하면 되기 때문)
만약 특정 숫자를 대입했을 때 더 이상 진행할 수 없으면, 이전 상태로 돌아가 다른 숫자를 시도
또한
int nx = (row / 3) * 3;
int ny = (col / 3) * 3;
스도쿠에선 항상 3 * 3 박스는 저 수식이 성립한다.

### 🤔 후기
처음에는 처음부터 배열을 돌면서 0인 부분을 찾으면 재귀를 들어가야겠다고 생각했지만 굳이 그럴 필요가 없었다. 힌트와 정답 코드를 보며 이해하였는데, 미리 빈칸인 부분을 저장 해두면 빈칸인 부분부터 바로 접근 하면 되었다.
 
---

# 🧩 문제

## [칸토어 집합 - 4779](https://www.acmicpc.net/problem/4779)

### 💡 아이디어 / 접근법
함수는 문자열의 특정 구간을 1/3씩 나누고, 중간 1/3 구간을 공백으로 채운 후, 나머지 1/3 구간에 대해 좌, 우로 나누어 재귀를 수행, 구간의 길이가 2 미만이면 더 이상 나눌 수 없으므로 재귀를 종료

### 🤔 후기
1/3씩 나누는건 알겠는데 중간에 공백을 주면 좌, 우가 나눠지고 그 나눠진거에 대한 분할 또 해야 해서 어떻게 해야 할지 막막했다.

---

# 🧩 문제

## [N-Queen - 9663](https://www.acmicpc.net/problem/9663)

### 💡 아이디어 / 접근법
각 행에 퀸을 하나씩 배치하면서, 이전 행의 퀸들과 같은 열이나 대각선에 놓이지 않도록 검사
만약 안전한 위치를 찾으면 다음 행으로 재귀 호출하며, 충돌이 발생하면 해당 열 배치를 포기하고 다음 열을 시도
모든 행에 퀸을 성공적으로 배치하면 가능한 경우의 수를 증가시키고, 최종적으로 총 경우의 수를 출력
각 대각선은 i + j의 값이 같고 i - j 값이 같음을 이용
그리고 어차피 퀸은 놓게 되면 그 한 행에는 배치를 할 수 없기 때문에 1차원 배열로 진행


### 🤔 후기
처음에는 2차원 배열로 각각 다 접근 했는데 결국 시간초과가 나게 되어 힌트와 정답 코드를 보았다. 퀸은 놓게 되면 결국 그 행에는 놓지 못 하고 바로 다음행으로 가야 하기 때문에 1차원 배열을 통해 행을 표현하고, 숫자를 배열에 넣어 i, j 위치에 놓았음을 표시하였다.

---

# 🧩 문제

## [하노이 탑 이동 순서 - 11729](https://www.acmicpc.net/problem/11729)

### 💡 아이디어 / 접근법
원판의 개수(n)와 세 개의 기둥(출발, 보조, 목적지)을 인자로 넘긴다.
재귀적를 통해 'n-1'개의 원판을 보조 기둥으로 옮기고, 가장 큰 원판을 목적지로 옮긴 후, 다시 보조 기둥에 있던 'n-1'개의 원판을 목적지로 옮기는 과정을 반복
하노이 탑 이동의 총 횟수를 먼저 출력해야 하기 때문에 경우의 수(2^N - 1)를 먼저 계산하여 출력하고, 이어서 각 이동 단계를 기둥 번호 쌍으로 출력한다.


### 🤔 후기
사실 힌트와 정답을 봐도 이게 이해가 가장 힘든 문제였다. n - 1을 통해서 가장 위에 있는 원판에 접근하고 그 원판을 옮기기 위해 보조 기둥을 사용한다. 즉, 보조기둥 => 목적지까지 옮기기 위해 재귀를 활용하는걸로 이해했다.

---

# 🧩 문제

## [스타트와 링크 - 14889 ](https://www.acmicpc.net/problem/14889)

### 💡 아이디어 / 접근법
N명의 사람 중에서 N/2명을 'start' 팀으로 선택하는 모든 조합을 탐색 그럼 자동으로 나머지는 link 팀이 된다.
각 팀 구성이 결정되면, 각 팀의 능력치 합을 계산하고 그 차이를 구하여 최소값을 갱신
visited 배열을 사용하여 현재 탐색 중인 조합에서 누가 start 팀에 속하는지를 관리하며, 재귀 호출 시 i + 1을 전달하여 중복 탐색을 방지
그리고 1, 2가 start 팀이면 start[1][2] + start[2][1]이기 때문에 visited[i]와 [j]가 같은 것들만 더하면 된다.


### 🤔 후기
힌트를 봤을 때는 잘 이해가 안됐었는데, 결국 팀을 정하면 그 숫자에 해당하는 인덱스 값을 더하게 되어 visited 배열을 1차원으로 하여 이중 for문을 돌게 되면 결국 ex) start[1][2]와 start[2][1]이 더해진다.

---

# 🧩 문제

## [N과 M (1) - 15649](https://www.acmicpc.net/problem/15649)

### 💡 아이디어 / 접근법
N개 중 M개를 뽑는 조합을 구하는 문제로 자기 자신을 더 뽑지 않는다 그렇기 때문에 visited를 활용하여 사용을 체크하고 다음 값으로 넘어가 M개를 뽑았으면 출력하고 다시 백트래킹을 통해 돌아간다.

### 🤔 후기
조합을 만드는 정석적인 문제 같다. 기저 조건과 재귀 호출을 어디서 어떻게 할지만 알면 쉽게 풀 수 있는 문제

---

# 🧩 문제

## [N과 M (2) - 15650](https://www.acmicpc.net/problem/15650)

### 💡 아이디어 / 접근법
이건 자기 자신을 포함하지만 이전에 사용했던 값들은 중복으로 취급 하기 때문에 항상 이전에 사용했던 수 보다 큰 값을 인자로 넣으면 된다.


### 🤔 후기
처음에는 visited를 어떻게 활용할까 고민했지만 결국 자기 자신을 포함하기 때문에 visited를 사용할 필요 없이 다음 재귀 호출 인자를 이전 값 보다 큰 값으로 넣으면 되었다.

---

# 🧩 문제

## [N과 M (3) - 15651](https://www.acmicpc.net/problem/15651) 

### 💡 아이디어 / 접근법
자기 자신을 포함해 중복도 허용하기 때문에 0부터 시작하여 전체 경우를 전부 뽑으면 된다. 

### 🤔 후기
N과 M 1 코드에서 visited 체크를 하지 않으면 자기 자신을 포함한 전체 경우를 뽑게 된다.

---

# 🧩 문제

## [N과 M (4) - 15652](https://www.acmicpc.net/problem/15652)

### 💡 아이디어 / 접근법
중복을 포함하지 않지만 자기 자신은 포함하기 때문에 자기 자신부터 인자를 넣으면 된다.


### 🤔 후기
N과 M 2에서 중복을 허용하지 않고 자기 자신을 포함하지 않았기 때문에 i + 1를 넣었지만 이번 4같은 경우는 자기 자신을 포함하기 때문에 i를 넣으면 되었다.

---