# 이번주 풀이 문제🧩

| 번호 | 문제 | 번호 | 문제 | 번호 | 문제 | 번호 | 문제 |
|:--:|:--|:--:|:--|:--:|:--|:--:|:--|
| **1** | [분수 합 - 1735](https://www.acmicpc.net/problem/1735) | **2** | [소수 구하기 - 1929](https://www.acmicpc.net/problem/1929) | **3** | [최소공배수 - 1934](https://www.acmicpc.net/problem/1934) | **4** | [가로수 - 2485](https://www.acmicpc.net/problem/2485) |
| **5** | [다음 소수 - 4134](https://www.acmicpc.net/problem/4134) | **6** | [베르트랑 공준 - 4948](https://www.acmicpc.net/problem/4948) | **7** | [최소공배수 - 13241](https://www.acmicpc.net/problem/13241) | **8** | [창문 닫기 - 13909](https://www.acmicpc.net/problem/13909) |
| **9** | [골드바흐 파티션 - 17103](https://www.acmicpc.net/problem/17103) |  |

---

# 🧩 문제

## [분수 합 - 1735](https://www.acmicpc.net/problem/2581)

### 💡 아이디어 / 접근법
분수의 합을 이용하여 분자와 분모를 만든 후 각 분자와 분모를 분자와 분모의 최대 공약수로 나누게 되면 더 이상 나누어 떨어지지 않는 기약분수가 된다.
유클리드 호제법을 이용하여 최대 공약수를 구하고 더한 각 분자와 분모를 최대 공약수로 나누어 준다.


### 🤔 후기
최대 공약수를 구하고 분수 덧샘 후 각 분자와 분모를 나누어 주면 되는 문제

---

# 🧩 문제

## [소수 구하기 - 1929](https://www.acmicpc.net/problem/1929)

### 💡 아이디어 / 접근법
에라토스테네스의 채를 구현

### 🤔 후기
에라토스테네스의 채를 구현하기만 하면 쉽게 풀 수 있음

---

# 🧩 문제

## [가로수 - 2485](https://www.acmicpc.net/problem/2485)

### 💡 아이디어 / 접근법
전체 길이를 각 차의 최대 공약수로 나누게 되면 일정한 간격의 개수가 나오게 된다. 그 간격 사이에 나무를 심으면 되기 때문에 나누어준 값에 +1을 하게 되면 나무의 개수를 구할 수 있다.

### 🤔 후기
최대 공약수가 나무의 일정한 간격이므로 간격 사이에 나무를 심어야 하기 때문에 +1을 꼭 해줘야 했다,

---

# 🧩 문제

## [다음 소수 - 4134](https://www.acmicpc.net/problem/4134)

### 💡 아이디어 / 접근법
n 이상의 가장 작은 소수를 찾으면 되므로 에라토스테네스의 채를 이용하여 소수 배열을 미리 만들어 둔 뒤 n부터 1씩 증가시키며 소수 배열에 접근 하여 true 부분의 인덱스를 반환 

### 🤔 후기
for문 안의 i도 long long으로 지정을 해줬어야 했다. 숫자가 매우 크므로 int를 사용하게 되면 풀리지 않아서 좀 열받는 문제 

---

# 🧩 문제

## [최소공배수 - 13241](https://www.acmicpc.net/problem/13241)

### 💡 아이디어 / 접근법
유클리드 호제법 구현

### 🤔 후기
유클리드 호제법을 구현할 줄 알면 쉽게 풀리는 문제였다.

---

# 🧩 문제

## [창문 닫기 - 13909](https://www.acmicpc.net/problem/13909)

### 💡 아이디어 / 접근법
직접 규칙을 찾아본 결과 완전 제곱일 때만 창문이 열렸다. 그래서 i * i <= N을 만족하는 갯수를 구하면 됨

### 🤔 후기
처음에는 1, 2일 때는 다른 줄 알고 예외처리를 하였지만 생각해 보니 예외처리를 할 필요가 없었다.

---

# 🧩 문제

## [골드바흐 파티션 - 17103](https://www.acmicpc.net/problem/17103)

### 💡 아이디어 / 접근법
-첫 번째: 에라토스테네스의 채를 미리 만들어 둔 후 n이하의 소수들을 따로 배열에 담아 투 포인터를 활용하여 두 합이 n을 만족시키는 갯수를 찾음

-두 번째: 에라토스테네스의 채를 만들고, i와 n - i를 활용하여 두 수가 모두 소수라면 갯수 +1

### 🤔 후기
투 포인터 방법은 c++에선 문제 없이 작동했지만 python에선 입력이 바뀔 때마다 배열을 새로 생성하는것이 시간이 너무 오래걸렸다. 그래서 i와 n - i의 합이 n인걸 이용하여 i가 소수고 n - i도 소수라면 소수의 합으로 n을 만들 수 있기 때문에 배열을 생성하지 않고 미리 생성된 에라토스테네스의 채의 배열에 인덱스로만 접근하여 갯수를 세어 시간초과를 방지하였다.

---