# 이번주 풀이 문제🧩

| 번호 | 문제 | 번호 | 문제 | 번호 | 문제 | 번호 | 문제 |
|:--:|:--|:--:|:--|:--:|:--|:--:|:--|
| **1** | [1로 만들기 - 1463](https://www.acmicpc.net/problem/1463) | **2** | [잃어버린 괄호 - 1541](https://www.acmicpc.net/problem/1541) | **3** | [포도주 시식 - 2156](https://www.acmicpc.net/problem/2156) | **4** | [계단 오르기 - 2579](https://www.acmicpc.net/problem/2579) |
| **5** | [쉬운 계단 수 - 10844](https://www.acmicpc.net/problem/10844) | **6** | [ATM - 11399](https://www.acmicpc.net/problem/11399) | **7** | [주유소 - 13305](https://www.acmicpc.net/problem/13305) | **8** | [트럭 - 13335](https://www.acmicpc.net/problem/13335) |

---

# 🧩 문제

## [1로 만들기 - 1463](https://www.acmicpc.net/problem/1463)

### 💡 아이디어 / 접근법
2부터 시작하여 dp의 배열을 채운다.
현재 값에서 -1을 하는 경우는 항상 성립할 수 있기 때문에 이전 값의 경우의 수에서 +1을 해준다.
그 후 현재 값이 2나 3으로 나눠진다면 나눠진 값에서 +1을 한 값과 -1을 한 현재 dp[i]의 값을 비교 하여 최솟 값으로 바꿔준다.
마지막으로 찾고자 하는 인덱스의 값을 출력한다.

### 🤔 후기
현재 값에서 -1을 하는 경우는 항상 성립하는걸 몰라서 힌트를 보았다. 이해하니까 쉽게 풀리는 문제

---

# 🧩 문제

## [잃어버린 괄호 - 1541](https://www.acmicpc.net/problem/1541)

### 💡 아이디어 / 접근법
괄호를 활용하여 가장 작은 수를 만들어야 하기 때문에 - 부호 이후로 나온 숫자들을 전부 빼주면 된다.
flag를 활용하여 -가 나오면 그 이후부터는 계속 빼준다.

### 🤔 후기
문자열로 입력 받기 때문에 숫자를 판별 하는게 조금 힘들었다.

---

# 🧩 문제

## [포도주 시식 - 2156](https://www.acmicpc.net/problem/2156)

### 💡 아이디어 / 접근법
연속해서 3잔을 마실 수는 없기 때문에

경우 1: i-1번째 잔과 i번째 잔을 마시는 경우 (한잔을 마시고 한칸 건너 뛴 후 두잔을 연속으로 마시는 경우)
→ i-3번째 잔까지의 최대값 + arr[i-1] + arr[i]

경우 2: i번째 잔만 마시는 경우 (한잔을 마시고 한칸 건너뛰고 한잔만 마시는 경우와 두잔을 마시고 한잔만 마시는 경우)
→ i-2번째 잔까지의 최대값 + arr[i]

경우 3: i번째 잔을 마시지 않는 경우
→ i-1번째 잔까지의 최대값 유지

마지막 잔을 반드시 마시지 않아도 되기 때문에 이전까지 마신 수도 확인


### 🤔 후기
계단오르기와 똑같은 점화식을 가지지만 마지막을 반드시 사용하는지 않하는지에 따라 점화식이 추가 되었다.

---

# 🧩 문제

## [계단 오르기 - 2579](https://www.acmicpc.net/problem/2579)

### 💡 아이디어 / 접근법
i번째 계단에 도달하는 경우는 두 가지

경우 1) i-2 → i
    - i-2 계단에서 두 칸 점프
    - 연속 3계단 금지 조건 만족
    - 점수: dp[i-2] + floor[i]

경우 2) i-3 → i-1 → i
    - i-3에서 한 칸 점프 → i-1 → i
    - i-1 → i 연속 2계단
    - i-2 건너뜀 → 연속 3계단 금지 조건 만족
    - 점수: dp[i-3] + floor[i-1] + floor[i]

마지막을 반드시 밟는 조건은 한칸을 밟았을 때 한칸 건너 뛰고 i - 1과 i를 연속으로 밟는 경우와 한 칸 건너 뛰고 바로 i를 밟는 경우 두가지 밖에 없음

### 🤔 후기
처음에는 1번을 밟지 않고 바로 2번으로 가는 경우를 고려했으나 사실 2번을 밟을거면 1번을 밟는게 가장 크기 때문에 의미가 없었다. 그래서 1번과 2번을 미리 넣어두고 점화식을 만든다.

---

# 🧩 문제

## [쉬운 계단 수 - 10844](https://www.acmicpc.net/problem/10844)

### 💡 아이디어 / 접근법
각 자릿수 마다 차이가 1만큼 나는 수의 갯수를 구하는 문제
그래서 dp 배열에 
길이가 1인 경우 1~9까지의 값 => [1][1 ~ 9]
길이가 2인 경우 1~9까지의 값 => [2][1 ~ 9]

길이가 1인 경우는 전부 1이기 때문에 1로 채워주고 2인 경우부터 시작한다.
점화식은 이전 자리 수에 해당하는 값의 -1인 경우와 +1인 경우의 수를 합하는거기 때문에
dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]이 되고
뒷자리가 0인 경우 1 밖에 없기 때문에 dp[i - 1][1]을 넣어주고 
9인 경우는 가능한 수는 8 밖에 없기 때문에 dp[i - 1][8]의 값을 넣어준다.
그 이후 N에 해당하는 배열의 모든 합을 구하면 된다.

### 🤔 후기
점화식을 제대로 찾았지만 1000000을 나눠주지 않아 틀린 문제

---

# 🧩 문제

## [ATM - 11399](https://www.acmicpc.net/problem/11399)

### 💡 아이디어 / 접근법
인출 시간이 짧은 사람 순서대로 정렬한 후 이전 사람의 값을 저장하고 현재 시간을 계속 더해준다.

### 🤔 후기
이전 사람의 값의 합을 계속 저장하여 현재 시간을 더해주면 되었다.

---

# 🧩 문제

## [주유소 - 13305](https://www.acmicpc.net/problem/13305)

### 💡 아이디어 / 접근법
최소 기름을 구하면 되기 때문에 
현재 주유소의 기름 값이 다음 주유소의 값보다 비싼 경우 
=> 다음 정류장까지의 거리만큼만 주유
현재 주유소의 기름 값이 다음 주유소의 값 보다 싼 경우
=> 현재 주유소에서 다음 길이만큼까지 주유

가장 저렴한 가격을 저장해두고 반복문을 돌면서 이후의 거리와 주유소 가격들을 확인 하여 가격이 저렴한 경우 mn 값을 바꾸고 아니면 유지하여 거리를 곱한 값을 계속 더해주면 된다.

### 🤔 후기
채점 방식이 재밌었다. 마지막 장소에선 주유할 필요가 없기 때문에 N이 아니라 N - 1까지만 확인 해야 한다. N까지 확인 하여 58점을 맞았다.

---

# 🧩 문제

## [트럭 - 13335](https://www.acmicpc.net/problem/13335)

### 💡 아이디어 / 접근법
트럭과 다리를 큐를 활용해 만들어준다.
다리는 다리의 길이만큼 0을 활용해 채워주고
트럭의 첫 번째 값이 다리의 무게 이하라면 트럭 큐에서 빼주고 시간을 더해준다.
그게 아니라면 0을 넣어주고 시간을 더해준다.
트럭이 전부 들어갔다면 다리에서 값을 빼주면서 시간을 더해준다.

### 🤔 후기
처음에는 트럭을 배열로 받았다가 트럭이 올라가지 못 하면 인덱스를 유지해야 하는데 그렇게 하다 보니 인덱스 에러가 나서 큐로 바꿨다. 이렇게 하니까 에러 없이 시뮬레이션 순서대로 트럭을 집어넣을 수 있었다. 
또한 다리에 있는 큐를 비워주지 않으니까 트럭만 삽입 되고 시간은 올라가지 않아 다리의 큐를 다리 길이만큼 0으로 채우고 다리의 큐를 비워주면서 시간을 더해줬다.

트럭이 다리라는 큐 안에서 움직이는 것처럼 구현하면 된다.

---