# 이번주 풀이 문제🧩

| 번호 | 문제 | 번호 | 문제 | 번호 | 문제 | 번호 | 문제 |
|:--:|:--|:--:|:--|:--:|:--|:--:|:--|
| **1** | [숨바꼭질 - 1697](https://www.acmicpc.net/problem/1697) | **2** | [미로 탐색 - 2178](https://www.acmicpc.net/problem/2178) | **3** | [N 찍기 - 2741](https://www.acmicpc.net/problem/2741) | **4** | [나이트의 이동 - 7562](https://www.acmicpc.net/problem/7562) |
| **5** | [토마토 - 7569](https://www.acmicpc.net/problem/7569) | **6** | [토마토 - 7576](https://www.acmicpc.net/problem/7576) | **7** | [동전 0 - 11047](https://www.acmicpc.net/problem/11047) | |

---

# 🧩 문제

## [숨바꼭질 - 1697](https://www.acmicpc.net/problem/1697)

### 💡 아이디어 / 접근법
최단거리를 찾아야 하기 때문에 bfs를 사용하였다.
시작점을 우선 큐에 넣고 해당 배열을 0초로 지정한다.
그리고 해당 배열의 이전 값에 각 조건에 맞게 시간을 증가시키고 가장 먼저 해당 위치에 도착하면 함수를 탈출 하고 배열의 해당 인덱스의 값을 출력한다.

### 🤔 후기
어차피 각 방문 순서대로 큐에 집어넣고 해당 조건에 대해 검사하기 때문에 가장 먼저 목표 위치에 도착한 값이 정답이다.

---

# 🧩 문제

## [미로 탐색 - 2178](https://www.acmicpc.net/problem/2178)

### 💡 아이디어 / 접근법
상하좌우로 이동할 수 있기 때문에 델타 탐색을 활용하고 최소로 이동한 칸을 출력해야 하기 때문에 bfs를 활용하였다.
인접칸을 조사하여 이동하고 이동한 칸은 이전 칸의 값에 +1을 해준다. 그렇게 되면 목표 위치까지 도달했을 때의 최소칸 수를 알 수 있다.

### 🤔 후기
델타 탐색 + bfs의 정석 문제였다.

---

# 🧩 문제

## [나이트의 이동 - 7562](https://www.acmicpc.net/problem/7562)

### 💡 아이디어 / 접근법
나이트는 고정된 8칸을 이동할 수 있기 때문에 델타 탐색과 마찬가지로 8개의 좌표를 미리 지정하여, 해당 칸으로 이동할 수 있도록 하였다.
그리고 bfs를 활용하여 이동 후 이전 칸의 값을 더해주고 배열의 목표 인덱스를 출력하면 최소 이동 거리가 나오게 된다.
여기서는 테스트케이스가 주어지므로 각 테스트케이스를 검사한 후 배열을 초기화 해줘야 다음 테스트케이스가 정상적으로 작동한다. 
 
### 🤔 후기
입력 값 받는게 생각보다 어려웠다. 나머지는 델타탐색 + bfs 문제와 별반 다를게 없었다. 테스트케이스가 여러개라 매번 배열을 초기화 해줘야 한다는 정도?

---

# 🧩 문제

## [토마토 - 7569](https://www.acmicpc.net/problem/7569)

### 💡 아이디어 / 접근법
3차원이므로 배열을 3차원으로 활용해 각 층으로 생각하고 해당 인덱스에 2차원 배열을 다시 입력 받는다.
1로 익은 토마토를 선별하여 큐에 삽입하고, 해당 위치의 상하좌우를 탐색한 후, 위와 아래를 다시 탐색하고 탐색 후 해당 위치에 이전 위치의 값을 더해준다. 
그리고 해당 배열에 0이 하나라도 있다면 -1을 출력하고 프로그램을 종료,
아니라면 최댓값을 계속 갱신하여 바꿔주고 1부터 시작하였으니 최댓값에 -1을 하고 출력한다. 

### 🤔 후기
3차원이라 3차원 배열을 활용해야겠다고 생각했고, 입력을 이제 층별로 나눠서 받아야 하는데 그게 생각보다 어려웠다. 그래서 3차원 배열이 잘 입력 됐는지 계속 디버깅을 했었다. 그 이후로는 [x][y]를 고정하고 높이를 확인하고, [h]를 고정하고 상하좌우를 확인하는 식으로 풀었다.

---

# 🧩 문제

## [토마토 - 7576](https://www.acmicpc.net/problem/7576)

### 💡 아이디어 / 접근법
2차원 토마토로 시작 위치가 여러곳이다. 그래서 1인 부분을 찾아 큐에 삽입하고, 인접한 상하좌우가 다음날 익기 때문에 델타 탐색 + bfs를 활용한다.
확인한 부분은 이전 값에 하루를 더해주고 익었으니 다시 큐에 삽입하여 준다.
이렇게 되면 익은 부분이 계속 먼저 들어오고 그 부분을 계속 확인하게 되기 때문에
해당 배열을 순회하면서 최댓값을 갱신해주고 0이 하나라도 있으면 -1을 출력하고 프로그램을 종료
아니라면 1부터 시작하였기 때문에 최댓값에 -1을 해주고 출력한다.

### 🤔 후기
처음에는 시작점이 여러개이고 이게 동시에 움직여야 하는데 어떻게 해야하지?라고 생각했다. 하지만 1인 부분을 큐에 삽입하게 되면 해당 부분부터 탐색을 시작하기에 전혀 걱정이 필요없는 문제다.

---

# 🧩 문제

## [동전 0 - 11047](https://www.acmicpc.net/problem/11047)

### 💡 아이디어 / 접근법
동전이 오름차순으로 주어지기 때문에 배열을 뒤에서부터 순회하여 큰 동전의 갯수부터 세어준다.
그리고 나머지를 해당 값으로 바꾸고 다시 다음 동전으로 나누어주는 식으로 갯수를 확인하면 된다.

### 🤔 후기
오름차순으로 주어지기 때문에 뒤에서부터 갯수를 세면 되는 문제

---