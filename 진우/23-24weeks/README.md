# 이번주 풀이 문제🧩

| 번호 | 문제 | 번호 | 문제 | 번호 | 문제 | 번호 | 문제 |
|:--:|:--|:--:|:--|:--:|:--|:--:|:--|
| **1** | [곱셈 - 1629](https://www.acmicpc.net/problem/1629) | **2** | [랜선 자르기 - 1654](https://www.acmicpc.net/problem/1654) | **3** | [종이의 개수 - 1780](https://www.acmicpc.net/problem/1780) | **4** | [수 찾기 - 1920](https://www.acmicpc.net/problem/1920) |
| **5** | [쿼드트리 - 1992](https://www.acmicpc.net/problem/1992) | **6** | [수열 - 2559](https://www.acmicpc.net/problem/2559) | **7** | [색종이 만들기 - 2630](https://www.acmicpc.net/problem/2630) | **8** | [행렬 곱셈 - 2740](https://www.acmicpc.net/problem/2740) |
| **9** | [구간 합 구하기 4 - 11659](https://www.acmicpc.net/problem/11659) | **10** | [구간 합 구하기 5 - 11660](https://www.acmicpc.net/problem/11660) | **11** | [인간-컴퓨터 상호작용 - 16139](https://www.acmicpc.net/problem/16139) | **12** | [암호 만들기 - 21553](https://www.acmicpc.net/problem/21553)| |

---

# 🧩 문제

## [곱셈 - 1629](https://www.acmicpc.net/problem/1629)

### 💡 아이디어 / 접근법
지수를 분할 정복하여 절반으로 계속 나누어 계산한다.
a^4 = a^2 * a^2
a^2 = a^1 * a^1

그리고 절반이 된 값을 곱하면 이전 값이므로 곱해주고 미리 나누어 주어야 하는 값을 나누어 준다.


### 🤔 후기
지수를 절반 나눈 값을 서로 곱하면 현재 값인것만 알면 쉽게 풀 수 있는 문제 하지만 그걸 생각하기가 쉽지 않았다.
 
---

# 🧩 문제

## [랜선 자르기 - 1654](https://www.acmicpc.net/problem/1654)

### 💡 아이디어 / 접근법
우선 랜선의 최대 길이를 저장한 후 이분탐색을 돌려준다. 최대 길이의 절반을 가지고 각 랜선의 길이를 나눈 후 cnt에 값을 더해 N과 같아질 때까지 이분 탐색을 반복

### 🤔 후기
기준 값을 무엇으로 잡아야 하는지 헷갈리는 문제였다. 기준 값을 잡게 되면 구현하는데 크게 어렵지는 않았다.
 
---

# 🧩 문제

## [종이의 개수 - 1780](https://www.acmicpc.net/problem/1780)

### 💡 아이디어 / 접근법
3으로 나누어 총 9개로 분할 해야 하기 때문에 9개의 첫 번째 인덱스를 재귀의 인자로 넣어서 계산 해준다.
그리고 재귀가 끝나 조건문을 만나면 모두 같은 영역이라는 뜻이므로 갯수를 추가한다.

### 🤔 후기
쿼드트리가 2분할이라면 이 문제는 3분할로 해당 분할 영역의 인덱스만 찾을 수 있다면 기존 문제처럼 풀 수 있다.

---

# 🧩 문제

## [수 찾기 - 1920](https://www.acmicpc.net/problem/1920)

### 💡 아이디어 / 접근법
이분탐색을 활용해 해당 입력 값을 바로 이분탐색 함수에 인자로 넣어서 첫 인덱스와 마지막 인덱스를 좌, 우로 두고 mid 값을 계산 mid 보다 값이 크면 left를 증가시키고 mid 보다 값이 작다면 right를 감소 시키면서 해당 값을 찾으면 1을 출력 못 찾으면 0을 출력한다.


### 🤔 후기
이분 탐색을 구현할 줄만 알면 풀 수 있는 문제

---

# 🧩 문제

## [쿼드트리 - 1992](https://www.acmicpc.net/problem/1992)

### 💡 아이디어 / 접근법
항상 2의 지수로 형성 되므로 4분면으로 나누어진다. 그래서 해당 길이를 2로 나눈 값을 가지고 해당 좌표 값을 나누어진 길이만큼 순회하면서 모든 영역이 같아질 때까지 재귀를 호출, 모든 영역이 같다면 조건문을 만나고 값을 더해준다.


### 🤔 후기
분할된 영역의 첫 좌표 값만 알면 풀 수 있다. 항상 나누어진 길이만큼 더해지면 되기 때문에 이걸 알아야 풀 수 있었다.

---

# 🧩 문제

## [수열 - 2559](https://www.acmicpc.net/problem/2559)

### 💡 아이디어 / 접근법
더해지는 범위를 미리 합하여 result라는 값으로 저장한 후 현재 배열에서 제일 앞의 값을 빼주고 그 뒤에 값을 더해주면서 배열이 끝날 때까지 반복한다 그리고 result의 값이 가장 큰 값으로 계속 갱신 해준다.


### 🤔 후기
합을 알면 첫 번째 값을 계속 빼주고 이후 값을 더해주면서 값을 알 수 있으므로 최댓값만 갱신해주면 된다.

---

# 🧩 문제

## [색종이 만들기 - 2630](https://www.acmicpc.net/problem/2630)

### 💡 아이디어 / 접근법
첫 번째 색상을 저장해두고 분할 정복을 통해 현재 색상과 다르면 계속 재귀를 호출하여 분할한다. 같다면 해당 값에 해당하는 부분을 더해주어 갯수를 올려준다.

### 🤔 후기
조합을 만드는 정석적인 문제 같다. 기저 조건과 재귀 호출을 어디서 어떻게 할지만 알면 쉽게 풀 수 있는 문제

---

# 🧩 문제

## [행렬 곱셈 - 2740](https://www.acmicpc.net/problem/2740)

### 💡 아이디어 / 접근법
행렬의 곱셈을 코드로 구현 해주면 된다. 3중 for문을 통해 인덱스를 맞추어 해당 배열의 값들을 서로 곱하여 더해준다.


### 🤔 후기
분할정복에 갇혀 어떻게 분할정복으로 구현해야 하나 고민했지만 3중 for문으로 직관적으로 구현하면 됐었다.

---

# 🧩 문제

## [구간 합 구하기 4 - 11659](https://www.acmicpc.net/problem/11659) 

### 💡 아이디어 / 접근법
dp배열을 통해 첫구간부터 각 구간까지의 누적된 합을 넣어준다. 그리고 해당하는 구간의 값은 해당 구간의 시작 누적합에서 마지막 구간의 누적합을 뺀 값이므로 dp[b] - ap[a - 1]이다. 

### 🤔 후기
해당 구간의 값은 시작 구간의 누적합을 마지막 구간의 누적합에서 빼주면 된다.

---

# 🧩 문제

## [구간 합 구하기 5 - 11660](https://www.acmicpc.net/problem/11660)

### 💡 아이디어 / 접근법
이차원 누적합으로 해당 구역의 합을 가지고 겹치는 영역을 빼주면 된다.
그걸 점화식으로 나타내면, dp[x2][y2] - dp[x1 - 1][y2] - dp[x2][y1 - 1] + dp[x1 - 1][y1 - 1]가 된다.


### 🤔 후기
각 영역의 인덱스를 잘 파악하여 누적된 합을 빼주고 더해주면 된다.

---

# 🧩 문제

## [인간-컴퓨터 상호작용 - 16139](https://www.acmicpc.net/problem/16139)

### 💡 아이디어 / 접근법
각 알파벳 별로 dp 배열을 생성하여 현재 문자 S[i]가 c와 같으면 인덱스에 값을 누적해준다. 
그럼 dp[c][i]는 0~i-1까지 문자 c의 개수가 저장되고 [l, r] 구간에서 문자 c의 개수 = dp[r+1] - dp[l]가 되므로 해당 값을 출력해준다. dp 배열은 0 ~ i-1까지 누적합이므로, r+1을 사용한다.


### 🤔 후기
미리 알파벳의 모든 갯수를 파악하여 해당 알파벳의 인덱스에 값을 누적해준 후 해당 구간의 값을 빼주면 되었다. 이걸 생각하기가 쉽지 않다.

---