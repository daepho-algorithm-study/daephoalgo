# 이번주 풀이 문제🧩

| 번호 | 문제 | 번호 | 문제 | 번호 | 문제 | 번호 | 문제 |
|:--:|:--|:--:|:--|:--:|:--|:--:|:--|
| **1** | [시그마 - 2355](https://www.acmicpc.net/problem/2355) | **2** | [Headshot - 3546](https://www.acmicpc.net/problem/3546) | **3** | [가장 긴 증가하는 부분 수열 - 11053](https://www.acmicpc.net/problem/11053) | **4** | [Toilet Seat - 11189](https://www.acmicpc.net/problem/11189) |
| **5** | [TicTacToe - 13227](https://www.acmicpc.net/problem/13227) | **6** | [Lots of Liquid - 25991](https://www.acmicpc.net/problem/25991) | **7** | [아깝게 놓친 COSS 장학금 - 33896 ](https://www.acmicpc.net/problem/33896) | |

---

# 🧩 문제

## [시그마 - 2355](https://www.acmicpc.net/problem/2355)

### 💡 아이디어 / 접근법
(첫항 + 마지막항) x 항의 개수 / 2

### 🤔 후기
단순 for문을 통해 더하면 시간초과가 발생한다. a ~ n까지의 합은 ((a + n) * (n - a - 1)) / 2이므로 해당 공식을 활용해서 풀어야 시간 초과가 발생하지 않는다. 

---

# 🧩 문제

## [Headshot - 3546](https://www.acmicpc.net/problem/3546)

### 💡 아이디어 / 접근법
생존확률이 가장 높은 행동을 취해야 한다.
현재 상황을 유지 했을 때의 생존 확률
=> (연속된 0의 갯수) / (0의 총 갯수)

돌렸을 때의 생존 확률
=> (0의 총 갯수) / (전체 칸의 갯수)

둘중 높은 것이 확률이 더 높으므로 둘을 계산하여 확률이 높은 쪽으로 행동을 취한다.

### 🤔 후기
처음에는 0의 갯수가 더 많으면 확률이 높다고 생각했다. 하지만 돌리는 경우와 돌리지 않았을 경우의 확률이 다르다. 그래서 두 가지 경우를 계산하여 높은 쪽으로 행동을 취해야 한다.

---

# 🧩 문제

## [가장 긴 증가하는 부분 수열 - 11053](https://www.acmicpc.net/problem/11053) 

### 💡 아이디어 / 접근법
저장된 이전 길이에서 현재 값을 이어 붙였을 때 길이가 가장 긴 부분을 골라야 한다.
현재 값을 고정하고 현재 보다 이전의 모든 값을 검사하여 이전 값 보다 큰 경우만 걸러낸다.
그 이후 현재 값을 유지하는 것과 이전 값에 이어 붙이는 경우 중 더 큰 값을 선택한다.
그 후 dp 배열을 순회하며 가장 큰 값을 찾아준다.
 
### 🤔 후기
arr[i] > arr[j]를 걸러냈는데 dp[i]가 dp[j] + 1 보다 큰 경우가 있을까 했는데 있었다.
A = {10, 20, 10, 30} 경우
i = 3 일 때 => dp = [1, 2, 1] 바로 이전 dp[j] = 1이지만 그 이전에 dp[1] + 1 한 값이 dp[3] 이 됐기 때문에 그냥 dp[j] + 1로 하게 되면 2로 덮어 씌여져 최댓값이 나오지 않게 된다. 

---

# 🧩 문제

## [Toilet Seat - 11189](https://www.acmicpc.net/problem/11189)

### 💡 아이디어 / 접근법
각 경우마다 시트를 움직힌 총 횟수를 저장하여 출력 해주면된다.

첫 번째 값을 기준으로 하여 현재 시트의 상태가 지금 들어온 사람과 다를 경우 횟수를 세주면 된다.

1. 전부 올리는 경우
D를 선호하는 사람은 내렸다가 나갈 때 다시 올려야 하므로 시트 위치를 항상 U로 초기화 해준다.

2. 전부 내리는 경우
U을 선호하는 사람은 올렸다가 나갈 때 다시 내려야 하므로 시트 위치를 항상 D로 초기화 해준다.

3. 이후 사람의 경우를 따르는 경우
시트의 변화가 있을 때만 횟수를 세어주면 된다.

### 🤔 후기
처음에는 총 올린 횟수와 총 내린 횟수를 구하는 것인줄 알았는데 각 경우의 시트 총 변경 횟수를 구하는거였다.

---

# 🧩 문제

## [TicTacToe - 13227](https://www.acmicpc.net/problem/13227)

### 💡 아이디어 / 접근법
배열은 3 x 3 고정이므로 3개의 값이 같으면 승리 다르면 패배를 입력해주면 된다.

### 🤔 후기
.이 빈칸인걸 고려하지 않아서 틀린 문제, 나머지는 인덱스를 고정해두고 풀면 쉽게 풀리는 문제였다.

---

# 🧩 문제

## [아깝게 놓친 COSS 장학금 - 33896 ](https://www.acmicpc.net/problem/33896)

### 💡 아이디어 / 접근법
정렬에 다양한 조건을 거는 문제 3가지의 정렬 조건을 맞추기 위해 함수를 활용해 각 조건에 맞춰 정렬을 해주면 된다.

### 🤔 후기
python은 튜플을 지정할 때 미리 정렬 조건을 선택할 수 있다.

---