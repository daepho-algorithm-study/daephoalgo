|                    이번주 풀이 문제🧩                    |                                                                                       |                                                     |
| :------------------------------------------------------: | :-----------------------------------------------------------------------------------: | :-------------------------------------------------: |
|  **1.** [동전 0](https://www.acmicpc.net/problem/11047)  |              **2.** [회의실 배정](https://www.acmicpc.net/problem/1931)               | **3.** [ATM](https://www.acmicpc.net/problem/11399) |
| **4.** [삼삼한수](https://www.acmicpc.net/problem/17252) | **5.** [리코쳇로봇](https://school.programmers.co.kr/learn/courses/30/lessons/169199) |                                                     |

# 🧩 문제

## [동전 0](https://www.acmicpc.net/problem/11047)

### 💡 아이디어 / 접근법

1. 내림차순 정렬
2. 높은 동전부터 K에서 나올 수 있는 몫 계산
3. K 값 현재 동전에서의 나머지 값으로 재할당
4. 카운트 리턴

### 🤔 후기

그리디 문제였고 오랜만에 그리디 풀어봤는데 생각보다 어려웠음 아침에 머리 안돌아갈 때 풀어서 그런 지는 몰라도 뭔가 잘 안된 것 같았음

## [회의실 배정](https://www.acmicpc.net/problem/1931)

### 💡 아이디어 / 접근법

1. 우선 끝나는 시간으로 정렬 만약, 끝나는 시간이 같다면 시작시간으로 정렬
2. 끝나는 시간 기준으로 다음 회의실 찾기
3. 이전에 끝난 회의실의 시간이 현재 시작하는 시간보다 작다면 회의실을 대여할 수 있으므로 회의실을 빌리고 현재 회의실의 끝나는 시간을 재할당
4. cnt 출력

### 🤔 후기

그리디 중에서 가장 유명한 회의실 문제 였고 끝나는 시간으로 정렬을 할 수 있다면 크게 어려운 문제는 아니었다고 생각함. 끝나는 시간과 다음 회의실의 시작 시간을 비교해서 카운팅 해주고 끝나는 시간 바꿔주면 되는 문제

**3.** [ATM](https://www.acmicpc.net/problem/11399)

### 💡 아이디어 / 접근법

1. 배열 오름차순으로 정렬
2. 순회해서 누적합에 합산
3. 결과에 누적합 합산

### 🤔 후기

오름차순 정렬 후 누적합 합산과 결과 누적만 하면 되는 문제

**4.** [삼삼한수](https://www.acmicpc.net/problem/17252)

### 💡 아이디어 / 접근법

1. n이 0 이라면 바로 출력
2. n 을 계속 나눠주며 나머지가 2라면 NO 출력
3. 아니라면 계속 나눠줌

### 🤔 후기

처음에는 그냥 n에서 가장 가까운 3의 제곱수를 찾은 다음 그 수에서 3씩 나눠가면서 구해주다가 마지막에 1, 3, 9 가 나오면 YES 아니면 NO 를 출력해주도록 했음 근데 시간초과가 나게 되었음. 그래서 생각을 해보다가 해당 숫자를 3진수의 관점에서 보면 2가 나머지로 나올 때 해당 자리의 숫자를 2번 썼다는 걸 파악하게 되었고 그렇게 풀다보니 성공했음

**5.** [리코쳇로봇](https://school.programmers.co.kr/learn/courses/30/lessons/169199)

### 💡 아이디어 / 접근법

1. 시작점의 좌표 찾아서 queue 에 넣기 거리를 반환해야 하므로 dist 값까지 같이 넣기
2. 최솟값을 찾는 문제이기 때문에 BFS 탐색 진행 해줌
3. 다음 좌표값이 D(장애물) 혹은 경계선을 벗어날 때 까지 계속 직진
4. 만약 다음 좌표값이 그대로라면(하나도 이동하지 않았다면 그 좌표는 무시함)
5. 다음 값이 "G" 라면 dist + 1 반환
6. 아니라면 방문 체크 후 다음에 갈 좌표와 dist + 1을 queue 에 넣고 계속 탐색 진행

### 🤔 후기

문제 자체는 크게 어렵지 않았음. 핵심은 nx, ny가 한 칸 이동할 때마다 갱신되는 것이 아니라 한 방향으로 미끄러지듯 이동하다가 더 이상 진행할 수 없을 때의 좌표로 갱신된다는 점을 이해하는 것이었음. 또한 도착 지점인 G 역시 멈출 수 있는 위치여야 하기 때문에 단순히 G를 지나치는 것만으로는 정답이 될 수 없고 G의 인접한 다음 칸이 경계선이거나 장애물(D)인 경우에만 도달 가능한 상태가 됨. 이로 인해 nx, ny를 결정할 때 한 번 더 이동했을 때 장애물 또는 경계인지 여부를 확인하는 로직이 필요했고 이 부분이 일반적인 BFS 문제와의 가장 큰 차이점이라고 느꼈음.

---
