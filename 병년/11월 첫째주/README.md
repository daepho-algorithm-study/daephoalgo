|                     이번주 풀이 문제🧩                     |                                                              |                                                             |
| :--------------------------------------------------------: | :----------------------------------------------------------: | :---------------------------------------------------------: |
|     **1.[빙산](https://www.acmicpc.net/problem/2573)**     | **2.[쉬운 최단거리](https://www.acmicpc.net/problem/14940)** | **3.[나이트의 이동](https://www.acmicpc.net/problem/7562)** |
|  **4.[인구 이동](https://www.acmicpc.net/problem/16234)**  |   **5.[숨바꼭질3](https://www.acmicpc.net/problem/13549)**   |  **6.[숨바꼭질4](https://www.acmicpc.net/problem/13913)**   |
|     **7.[치즈](https://www.acmicpc.net/problem/2638)**     |   **8.[아기상어](https://www.acmicpc.net/problem/16236)**    | **9.[탈주범 검거](https://www.acmicpc.net/problem/19538)**  |
| **10.[개리멘더링](https://www.acmicpc.net/problem/17471)** |                                                              |                                                             |

# 🧩 문제

## [빙산](https://www.acmicpc.net/problem/2573)

### 💡 아이디어 / 접근법

1. 인접한 바다의 개수를 세어 빙산 녹이기
2. BFS 함수를 통한 빙산의 덩어리 세기
3. while 문 반복을 돌리면서 빙산의 개수를 세고 녹이고 반복하다가 빙산의 개수가 2개가 넘어가면 얼마나 걸렸는 지 리턴
4. 아니라면 0 리턴

### 🤔 후기

어제 새벽에 풀다가 잠든 문젠데 처음에는 로직 분리 없이 BFS 내부에서 녹이고 개수 세는 로직을 한 번에 처리하려고 했음 그러다 보니 다음 빙산이 갱신이 안되고 반복적으로 파악을 할 수 없었음 그래서 1시간 넘게 풀다가 도움을 좀 받았습니다.. 결과적으로는 BFS로 인접한 좌표에 대해 조건을 수행하고 melt 함수로 배열의 변경을 실행하고 마지막으로 반영해주는 사실상 요구사항대로 차근차근 풀면 풀리는 문제였던 것 같다..

**2.** [쉬운 최단거리](https://www.acmicpc.net/problem/14940)

### 💡 아이디어 / 접근법

1. 2의 위치 찾기
2. 새로운 배열 만들기
3. BFS 돌리면서 새 배열에 기록하기
4. 끝

### 🤔 후기

금방 생각해서 정답이 쉽게 나오길래 바로 제출했는데 3%에서 자꾸 틀리더라 알고보니까 출력 방식이 달라서 그랬더라..

**3.** [나이트의 이동](https://www.acmicpc.net/problem/7562)

### 💡 아이디어 / 접근법

1. 시작 좌표에서 끝 좌표까지 계속 이동하면서 카운트 누적
2. 나이트의 이동 경로에 따른 델타 배열 선언
3. BFS 돌리면서 카운트 누적
4. 끝

### 🤔 후기

아이디어 생각이랑 푸는데는 20분도 안걸렸는데 입력에서 헤맸음 JS 입력 왤케 어려움..? 또 dx 마지막 값이 -2 가 되었어야 하는데 잘못 생각해서 좀 걸렷음

**4.** [인구 이동](https://www.acmicpc.net/problem/16234)

### 💡 아이디어 / 접근법

1. 실제로 인구가 이동하는 함수
2. BFS 를 통한 연합 배열 생성
3. while 문으로 연합 생성하고 해당 연합에 속한 나라가 1이 넘는다며(단독 연합이 아니라면) 이동가능하다고 보고 실제 이동시키기
4. 그러고 얼마나 걸렸는 지 출력하기

### 🤔 후기

진짜 개인적으로 개 어려웠다고 생각했음 이것도 따지고보면 요구사항대로 차근차근 구현하면 되는 문제인데 그냥 되게 어려웠던 것 같음

**5.** [숨바꼭질3](https://www.acmicpc.net/problem/13549)

### 💡 아이디어 / 접근법

1. 시작 좌표에서 끝 좌표까지 계속 이동하면서 시간 누적
2. 방문체크 하면서 탐색
3. 경우에 따라서 다르게 처리 \*2일 경우 +0초 아닐 경우 +1초
4. 끝

### 🤔 후기

숨바꼭질 마스터했다고 생각해서 빠르게 풀어야지 하고 풀었다 실제로 답은 진짜 10분도 안 걸려서 나왔는데 계속 엄청 틀리더라.. 정신 나갈 거 같아서 1시간 붙잡다가 찾아봤는데 로직 순서가 중요하단다;; 그 전까지는 안그랬는데 0초일 경우 즉 \*2 의 경우 일때는 push 가 아닌 대가리 쪽에 넣어서 우선순위를 높여야 하는 우선순위 큐 + BFS 문제였다. 역시 골드 문제는 괜히 골드 문제가 아니구나 너무 어렵다...

**6.** [숨바꼭질4](https://www.acmicpc.net/problem/13913)

### 💡 아이디어 / 접근법

1. 시작 좌표에서 끝 좌표까지 계속 이동하면서 시간 누적
2. 방문체크 하면서 탐색 및 부모 좌표 즉 이전 좌표 저장
3. 경우에 따라서 다르게 처리 \*2일 경우 +0초 아닐 경우 +1초
4. 반복문을 통해 좌표 출력

### 🤔 후기

이 문제는 진짜 어떻게 풀이해야 할 지 감이 되게 안왔다. 어떻게 하면 경로를 추적해서 답을 찾을 수 있을까? 가 고민이었는데 그 문제는 배열을 하나 만들어서 이전 좌표 값을 현재 index 값에 저장하면 될 것이라고 생각했다. 근데 이 문제도 자꾸 답이 틀리길래 봤더니 이 문제 또한 우선순위가 중요한 문제 였다.

**7.**[치즈](https://www.acmicpc.net/problem/2638)

### 💡 아이디어 / 접근법

1. 공기가 어떤 곳에 위치해 있는 지 판별하는 BFS 함수
2. 공기 배열을 통해 치즈 녹이기 함수
3. 원본 배열 복사해서 모든 배열 검사했을 때 녹일 수 있는 치즈가 없다면 결과 리턴

### 🤔 후기

진짜 개 어려웠음 1시간 넘게 풀다가 GG 쳤고 처음에 나는 치즈 기준으로 인접한 곳이 공기인 지 공기가 아닌 지 판단해서 공기의 수가 2개 이상이면 치즈를 녹이는 방식으로 생각을 했었음 근데 풀다보니 그러면 치즈 내부의 공기는 어떻게 건드리지 않게 할 수 있지? 또 치즈 내부의 공기임을 어떻게 파악할 수 있지? 에 대한 부분에서 막히게 되었다. 그래서 결국 찾아보다가 공기를 기준으로 BFS 를 수행해서 공기에 대한 위치를 가지는 배열을 반환하고 시작 좌표를 무조건 0, 0 으로 고정한 뒤 arr[nx][ny] 값이 0인 경우, 아직 공기인 지 판별되지 않은 경우에만 BFS 탐색을 진행하는 걸로 하였다. 그 후, 녹이기 함수를 통해 현재 칸이 치즈이면서 인접한 칸이 공기일 경우에 카운팅을 해주었고 해당 카운트가 2가 넘어갈 경우 새로운 배열에 좌표값을 추가해주었다. 마지막으로 해당 좌표 값을 통해 실제 배열 값을 변경하는 반복문을 돌리고 로직 부분에서의 while 문을 통해 공기인 지 아닌지 판별하는 bfs 함수 호출과 해당 배열로 실제 치즈를 녹이고 시간 값을 증가하고 배열을 복사하여 모든 요소의 값을 계산해서 모든 요소가 0이라면 즉 치즈가 모두 녹았다면 반복문을 탈출하고 시간 값을 출력해주었다.
진짜 요즘에 BFS 풀면서 다시 벽에 막히는 기분이고 너무 어렵다..

**8.**[아기상어](https://www.acmicpc.net/problem/16236)

### 💡 아이디어 / 접근법

1. 상어의 위치를 찾기
2. 상어가 먹을 수 있는 물고기와 해당 물고기에 도달하는 시간을 담은 BFS 탐색
3. 먹을 수 있는 물고기 중 우선순위 찾기
4. 물고기를 먹어서 없애기

### 🤔 후기

이것도 너무 어려웠다..BFS 함수로 먹을 수 있는 물고기의 좌표와 걸리는 시간 반환해주는 거는 금방 짰고 실제로 물고기 먹는 함수도 금방 짰는데 도대체 우선순위를 어떻게 정렬하는 지 도저히 모르겠더라.. 문제에서 요구하는 게 물고기의 거리가 가까운 게 많으면 가장 위에 부터 먹고 그러한 물고기가 많다면 가장 왼쪽의 몰고기를 먹는다는데 이게 무슨 소리인 지 도저히 알 수가 없었다... 무슨 말이야 저게 진짜 그래서 이 부분 찾아봤는데 그러니까 결국 저 말은 거리 기준으로 먼저 정렬하고 그 다음 행 기준으로 정렬하고 마지막으로 열 기준으로 정렬하라는 의미였다.. 그래서 먼저 time 순으로 정렬하고 그런 물고기가 여러 마리일 경우 x 기준으로 정렬 여기서도 또 여러 마리라면 y 기준으로 정렬하라는 의미였다.. 그렇게 해서 함수들 작성이 다 끝났고 결과를 표시했는데 테케가 막히더라 이 부분도 찾아보게 되었는데 초기 상어의 위치를 0으로 바꿔주어서 다시 그 자리로 돌아갈 수 있도록 해야한다고 하더라.. 하긴 초기에 9로 주어지니까 9일 경우에는 어떤 경우도 못하니까 바꿔주는 게 필요했던 거지... 아니 진짜 너무 어렵다 BFS + 시뮬레이션 크아아아악

**9**.[탈주범 검거](https://www.acmicpc.net/problem/16236)

### 💡 아이디어 / 접근법

1. 이동할 수 있는 터널의 좌표 정의
2. 배열에서 터널에 속하는 좌표의 점들을 뽑아서 bfs 진행
3. 다음에 갈 수 있는 터널의 좌표 안에 현재 좌표의 반대 좌표가 들어있는 지 확인한 뒤 bfs 탐색 이어서 하기
4. 결과값 도출

### 🤔 후기

이거는 과거에 풀었던 탈주범 검거를 다시 한 번 풀어보자는 얘기를 들어서 다시 한번 풀어봤는데 문제 자체는 쉬웠다. 어떤 경우에 터널이 연결되어 있는 지 생각하면 쉽게 풀리는 문제였던듯? 근데 좌표값 정의할 때 생각보다 틀릴 수 있어서 다시 검사 해보고 할 것.

**10**.[게리맨더링](https://www.acmicpc.net/problem/17471)

### 💡 아이디어 / 접근법

1. 인접한 선거구의 조합 만들기
2. 모르겠다 그냥
3. 너무 어렵다
4. 나중에 채울게요..

### 🤔 후기

지금 문제 푸는 중인데 복기 좀 하고 있습니다.. 
---
