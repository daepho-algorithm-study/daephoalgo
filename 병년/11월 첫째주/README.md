|                 이번주 풀이 문제🧩                  |                                                               |                                                              |
| :-------------------------------------------------: | :-----------------------------------------------------------: | :----------------------------------------------------------: |
| **1.** [빙산](https://www.acmicpc.net/problem/2573) | **2.** [쉬운 최단거리](https://www.acmicpc.net/problem/14940) | **3.** [나이트의 이동](https://www.acmicpc.net/problem/7562) |
|                       **4.[인구 이동](https://www.acmicpc.net/problem/16234)**                        |                            **5.[숨바꼭질3](https://www.acmicpc.net/problem/13549)**                             |                            **6.[숨바꼭질4](https://www.acmicpc.net/problem/13913)**                            |


# 🧩 문제

## [빙산](https://www.acmicpc.net/problem/2573)

### 💡 아이디어 / 접근법

1. 인접한 바다의 개수를 세어 빙산 녹이기
2. BFS 함수를 통한 빙산의 덩어리 세기
3. while 문 반복을 돌리면서 빙산의 개수를 세고 녹이고 반복하다가 빙산의 개수가 2개가 넘어가면 얼마나 걸렸는 지 리턴
4. 아니라면 0 리턴

### 🤔 후기

어제 새벽에 풀다가 잠든 문젠데 처음에는 로직 분리 없이 BFS 내부에서 녹이고 개수 세는 로직을 한 번에 처리하려고 했음 그러다 보니 다음 빙산이 갱신이 안되고 반복적으로 파악을 할 수 없었음 그래서 1시간 넘게 풀다가 도움을 좀 받았습니다.. 결과적으로는 BFS로 인접한 좌표에 대해 조건을 수행하고 melt 함수로 배열의 변경을 실행하고 마지막으로 반영해주는 사실상 요구사항대로 차근차근 풀면 풀리는 문제였던 것 같다..

**2.** [쉬운 최단거리](https://www.acmicpc.net/problem/14940)

### 💡 아이디어 / 접근법

1. 2의 위치 찾기
2. 새로운 배열 만들기
3. BFS 돌리면서 새 배열에 기록하기
4. 끝

### 🤔 후기

금방 생각해서 정답이 쉽게 나오길래 바로 제출했는데 3%에서 자꾸 틀리더라 알고보니까 출력 방식이 달라서 그랬더라..

**3.** [나이트의 이동](https://www.acmicpc.net/problem/7562)

### 💡 아이디어 / 접근법

1. 시작 좌표에서 끝 좌표까지 계속 이동하면서 카운트 누적
2. 나이트의 이동 경로에 따른 델타 배열 선언
3. BFS 돌리면서 카운트 누적
4. 끝

### 🤔 후기

아이디어 생각이랑 푸는데는 20분도 안걸렸는데 입력에서 헤맸음 JS 입력 왤케 어려움..? 또 dx 마지막 값이 -2 가 되었어야 하는데 잘못 생각해서 좀 걸렷음

**4.** [인구 이동](https://www.acmicpc.net/problem/16234)

### 💡 아이디어 / 접근법

1. 실제로 인구가 이동하는 함수
2. BFS 를 통한 연합 배열 생성
3. while 문으로 연합 생성하고 해당 연합에 속한 나라가 1이 넘는다며(단독 연합이 아니라면) 이동가능하다고 보고 실제 이동시키기 
4. 그러고 얼마나 걸렸는 지 출력하기

### 🤔 후기

진짜 개인적으로 개 어려웠다고 생각했음 이것도 따지고보면 요구사항대로 차근차근 구현하면 되는 문제인데 그냥 되게 어려웠던 것 같음

**5.** [숨바꼭질3](https://www.acmicpc.net/problem/13549)

### 💡 아이디어 / 접근법

1. 시작 좌표에서 끝 좌표까지 계속 이동하면서 시간 누적
2. 방문체크 하면서 탐색
3. 경우에 따라서 다르게 처리 *2일 경우 +0초 아닐 경우 +1초
4. 끝

### 🤔 후기

숨바꼭질 마스터했다고 생각해서 빠르게 풀어야지 하고 풀었다 실제로 답은 진짜 10분도 안 걸려서 나왔는데 계속 엄청 틀리더라.. 정신 나갈 거 같아서 1시간 붙잡다가 찾아봤는데 로직 순서가 중요하단다;; 그 전까지는 안그랬는데 0초일 경우 즉 *2 의 경우 일때는 push 가 아닌 대가리 쪽에 넣어서 우선순위를 높여야 하는 우선순위 큐 + BFS 문제였다. 역시 골드 문제는 괜히 골드 문제가 아니구나 너무 어렵다...

**6.** [숨바꼭질4](https://www.acmicpc.net/problem/13913)

### 💡 아이디어 / 접근법

1. 시작 좌표에서 끝 좌표까지 계속 이동하면서 시간 누적
2. 방문체크 하면서 탐색 및 부모 좌표 즉 이전 좌표 저장
3. 경우에 따라서 다르게 처리 *2일 경우 +0초 아닐 경우 +1초
4. 반복문을 통해 좌표 출력

### 🤔 후기

이 문제는 진짜 어떻게 풀이해야 할 지 감이 되게 안왔다. 어떻게 하면 경로를 추적해서 답을 찾을 수 있을까? 가 고민이었는데 그 문제는 배열을 하나 만들어서 이전 좌표 값을 현재 index 값에 저장하면 될 것이라고 생각했다. 근데 이 문제도 자꾸 답이 틀리길래 봤더니 이 문제 또한 우선순위가 중요한 문제 였다. 


---
