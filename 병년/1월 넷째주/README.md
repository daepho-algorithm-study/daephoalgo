|                     이번주 풀이 문제🧩                     |                                                            |                                                             |
| :--------------------------------------------------------: | :--------------------------------------------------------: | :---------------------------------------------------------: |
| **1.** [이분 그래프](https://www.acmicpc.net/problem/1707) | **2.** [트리의 지름](https://www.acmicpc.net/problem/1967) | **3.** [트리의 지름2](https://www.acmicpc.net/problem/1167) |
| **4.** [내리막길](https://www.acmicpc.net/problem/1520)()  |                        **5.** []()                         |                                                             |

# 🧩 문제

## [이분 그래프](https://www.acmicpc.net/problem/1707)

### 💡 아이디어 / 접근법

1. 먼저 현재 색상 아무 색상이나 색칠
2. 내 인접 노드 반대 색상으로 색칠
3. 재귀로 내려가기
4. 만약 인접한 노드가 색칠이 이미 되어 있는데 나와 같은 색상이라면 바로 종료

### 🤔 후기

용재형이 리뷰한 문제였고 그냥 루트 노드에서 시작해서 먼저 임의의 색상으로 색칠해놓고 다음 그래프
탐색하면서 인접한 노드가 이미 색상을 가지고 있을 때 나와 색상이 같으면 이분 그래프가 아니라고 판단하면
되는 문제였음. 형 말대로 문제 이해가 어렵지 문제는 어려운 난이도는 아니었음.

## [트리의 지름](https://www.acmicpc.net/problem/1967)

### 💡 아이디어 / 접근법

1. 무향 그래프에 인접한 노드(같은 레벨) 끼리는 거리 및 가중치 없음 => 트리 파싱
2. bfs 를 통해 현재 노드에서 가장 먼 노드 찾기
3. dist 배열을 bfs 함수 내부에 두고 다음 위치의 값을 현재 위치의 값에서 누적 예를 들어 현재 노드가
   1이고 1에서 2로 갈 때 비용이 3이 든다고 가정하면 dist[2] = dist[1] + 2 2에서 3을 갈 때 비용이 4라면 dist[3] = dist[2] + 3 === dist[3] = 2 + 3
4. bfs 반환 시에 다음에 갈 좌표의 값과 최종 거리를 반환하기 위해 객체로 반환
5. bfs를 통해 1번 노드(루트 노드)에서 가장 거리가 먼 노드 찾고 해당 노드에서 다시 bfs를 돌려 최종 거리 찾기

### 🤔 후기

아이디어 자체는 금방 떠올렸음. 2번의 bfs를 통해 첫 번째 bfs 에서는 노드를 찾고 두 번째 bfs에서는 최종 거리를 찾으면 되겠다라고 근데 거리 배열을 어떤 식으로 만들 지가 생각보다 어려웠던 것 같음 단순히 인덱스 값에 부모 노드에서의 비용을 누적 해주면 루트 노드에서 특정 노드 까지의 거리가 누적이 되는 건데 계속 max 값 기준으로 다시 할당하려다가 머리가 깨질 뻔 했음.. 그리고 반환 할 때 어떤 식으로 반환을 해줘야 노드와 최종 거리를 둘 다 반환할 수 있을 지 생각을 했음 처음에는 배열로 반환 하려고 했고 물론 0번째 인덱스는 노드 1번째 인덱스는 거리 이런식으로 했으면 상관 없었겠지만 더 좋은 방법이 있을 것이라고 생각했고 React 프로젝트에서 답을 얻었음 hook 구현할 때 return 에 객체 형식으로 반환하고 다른 파일에서 구조 분해 할당으로 변수 받을 수 있다는 걸... 나는 바보가 맞다...

## [트리의 지름2](https://www.acmicpc.net/problem/1167)

### 💡 아이디어 / 접근법

1. 무향 그래프에 인접한 노드(같은 레벨) 끼리는 거리 및 가중치 없음 => 트리 파싱
2. bfs 를 통해 현재 노드에서 가장 먼 노드 찾기
3. dist 배열을 bfs 함수 내부에 두고 다음 위치의 값을 현재 위치의 값에서 누적 예를 들어 현재 노드가
   1이고 1에서 2로 갈 때 비용이 3이 든다고 가정하면 dist[2] = dist[1] + 2 2에서 3을 갈 때 비용이 4라면 dist[3] = dist[2] + 3 === dist[3] = 2 + 3
4. bfs 반환 시에 다음에 갈 좌표의 값과 최종 거리를 반환하기 위해 객체로 반환
5. bfs를 통해 1번 노드(루트 노드)에서 가장 거리가 먼 노드 찾고 해당 노드에서 다시 bfs를 돌려 최종 거리 찾기

### 🤔 후기

바로 위에서 푼 트리의 지름이랑 뭐가 다른 문제냐고 할 수 있는데 정확하게 똑같은 문제가 맞다 근데 이제 입력값 파싱이 추가된..

## [내리막길](https://www.acmicpc.net/problem/1520)

### 💡 아이디어 / 접근법

(처음 생각)

1. dx, dy 배열로 델타탐색 준비
2. dfs 돌리기
3. 방문 체크하면서 내 현재 값보다 낮은 값으로만 이동
4. 끝에 다다르면 answer 에 추가

### 🤔 후기

이렇게 해서 그냥 쉬운 dfs 문제라고 생각했고 바로 풀고 제출했는데 시간초과가 나더라.. 그래서 다시 문제를 봤는데 출력 경로의 제한이 10억 이하고 M, N 이 500 이하의 자연수라네..? 이건 그냥 dfs 가 아니라고 생각했음. DP 다..

### 💡 아이디어 / 접근법

(DP 로 변경)

1. dx, dy 배열로 델타탐색 준비
2. dfs 돌리기
3. dp 배열에 현재 값 표시
4. 끝에 도달하면 1 반환
5. 만약 이미 갔던 곳이라면 바로 해당 거리에서 갈 수 있는 경우의 수 반환
6. dfs 를 돌리면서 dp[x][y] 에 끝까지 갈 수 있는 경우의 수 누적

### 🤔 후기

솔직히 말하면 dfs 이후에 dp 인걸 파악 했는데 dp 문제를 많이 풀어보질 않아서 어떻게 풀어야 할 지 조금 헤맸다. 그래서 아이디어를 물어봤는데 dp 배열에 끝 까지 갈 수 있는 값 누적하고 만약 갔다면 그거 재사용하면 내가 현재 위치에서 갈 수 있는 경로 나오니까 그렇게 풀면 된다 예를 들어서 현재 0,0 에서 갈 수 있는 경로가 (1, 0), (0, 1) 이고 이 값들이 dp[1][0] === 2 dp[0][1] === 1 이라면 사실 0, 0 에서 갈 수 있는 경로는 해당 경로들을 합한 3이 나오기 때문이다.

---
