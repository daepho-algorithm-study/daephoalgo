|                     이번주 풀이 문제🧩                      |                                                            |                                                      |
| :---------------------------------------------------------: | :--------------------------------------------------------: | :--------------------------------------------------: |
| **1.** [점프왕 쩰리](https://www.acmicpc.net/problem/16173) | **2.** [전쟁 - 전투](https://www.acmicpc.net/problem/1303) | **3.** [침투](https://www.acmicpc.net/problem/13565) |
|    **4.** [저울](https://www.acmicpc.net/problem/10159)     |   **5.** [키 순서](https://www.acmicpc.net/problem/2458)   | **6.**[미친로봇](https://www.acmicpc.net/problem/1405)                                                      |
**7.** [가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053) |    **8.** [가장 긴 감소하는 부분 수열](https://www.acmicpc.net/problem/11722)     |   **9.** [전깃줄](https://www.acmicpc.net/problem/2565)   |                                                |

# 🧩 문제

## [점프왕 쩰리](https://www.acmicpc.net/problem/16173)

### 💡 아이디어 / 접근법

1. dfs 를 통해서 탐색
2. 먼저 아래쪽부터 내려가보고 목표점에 닿을 수 있는 지 판단
3. 아니라면 오른쪽 탐색
4. dfs 탐색 결과에 따라 값 출력

### 🤔 후기

처음에는 델타로 풀려고 했는데 현재 위치에 따라서 유동적으로 이동 가능한 칸의 수가 바뀌기 때문에 이렇게 풀면 안된다고 판단했음. 그래서 먼저 오른쪽 혹은 아래로 가면서 현재 위치 만큼 점프를 해보고 끝에 도달할 수 있으면 true 반환 그게 아니라면 나머지 방향으로 가보면서 탐색을 진행하는 것으로 변경했음. 그냥 델타 + dfs 만 풀다가 이런 문제는 많이 안 풀어본 것 같아서 풀어봤는데 조금 어려웠음.

## [전쟁 - 전투](https://www.acmicpc.net/problem/1303)

### 💡 아이디어 / 접근법

1. dfs / bfs 를 통해 같은 색상끼리의 그룹을 묶어주고 해당 그룹에 몇 개의 색상이 들어있는 지 판단
2. w 색상과 b 색상의 총합 값에 한 번의 탐색이 끝날 때 제곱한 값 합산
3. w 색상, b 색상 출력

### 🤔 후기

과거에 파이썬으로 풀었기도 했고 어려운 문제는 아니다 보니 금방 풀었는데 오답이 계속 났었음 알고 보니까 가로가 N 이고 세로가 M 이라서 입력 값 받을 때 문제가 있었음. 문제 좀 잘 봐야 될 거 같다..

## [침투](https://www.acmicpc.net/problem/13565)

### 💡 아이디어 / 접근법

1. dfs 를 통해 x의 값이(세로의 값) M - 1(끝까지 내려갔다면)
2. true 값 반환하고 그렇지 않다면 false 반환
3. 또한 한 번이라도 true 값을 반환했으면 계속해서 true 값을 반환할 수 있도록 dfs 함수 후 바로 return을 하도록 함
4. 첫 번째 행에서 dfs 수행후 true 값 나오면 Yes 출력하고 함수 끝내기
5. 아니라면 No 출력

### 🤔 후기

그냥 델타랑 dfs 가 섞인 문제이고 금방 풀 수 있었음 근데 처음에는 기계적으로 모든 좌표에 대해 탐색을 진행하려고 했는데 결과 값이 덮어씌워지는 오류가 있었고 사실 첫 번째 행에 속해있는 원소만 조사하면 되는 문제여씀

## [저울](https://www.acmicpc.net/problem/10159)

### 💡 아이디어 / 접근법

(처음 생각)

1. 무향 그래프로 파싱
2. dfs 돌리기
3. cnt 값 누적해서 내려가기
4. N 값에서 cnt 값 빼서 비교할 수 없는 물건의 수 재기

### 🤔 후기

문제를 보자마자 입력 값이 의미하는 건 노드에서 노드 관계를 나타낸 거고 왔다 갔다 할 수 있어야 한다고 판단해서 무향 그래프로 입력값을 받아서 문제를 풀었음 근데 결과를 출력하고 곰곰히 생각해보니 무향 그래프로 해버리면 입력 값 자체가 의미가 없음 왜? 무향으로 받은 순간 A > B 나 B > A나 똑같기에 무게 비교가 의미가 없기 때문이었음

### 💡 아이디어 / 접근법

(그래프 두개)

1. 정방향 그래프, 역방향 그래프
2. dfs / bfs 돌리기
3. 반복문 돌릴 때마다 visited 배열 초기화 이유는 물건 별로 독립적이기 때문에 처음 시작할 때는 모든 위치에 대해 열려있어야 하기 때문
4. 두 그래프의 방향 정보 만큼(두 방향 정보 중에 하나라도 방문한 적 있는 경우라면) cnt 추가
5. N 값에서 cnt 값 빼서 결과 출력

### 🤔 후기

내가 왜 방향 정보가 없다고 판단했을까... 출력 값이 똑같이 나오니까 그랬던 거 같은데 조금만 생각해도 오류가 굉장히 많은 접근이었는데 아무튼 재미있는 문제였음.

## [키 순서](https://www.acmicpc.net/problem/2458)

### 💡 아이디어 / 접근법

1. 정방향 그래프, 역방향 그래프
2. dfs / bfs 돌리기
3. 반복문 돌릴 때마다 vistied 배열 초기화
4. 두 그래프의 방향 정보 만큼 cnt 추가
5. cnt === N 일 때 answer++

### 🤔 후기

아이디어를 보면 알겠지만 저울 문제랑 거의 동일한 문제엿음. 마지막 조건만 확실하게 자신의 키 순서를 아는 경우에만 카운팅을 해주면 되는 걸로 변경하면 되는데 이는 결국 모든 사람과 비교를 해봐야 하기 때문에 카운팅한 값이 N 과 동일하면 결과값을 하나씩 올려주면 됨.

## [미친로봇](https://www.acmicpc.net/problem/1405)

### 💡 아이디어 / 접근법

1. 중간값 기준으로 이동할 수 있도록 size를 2 * N + 1로 정의해둠
2. dfs 돌리기
3. 깊이가 N 만큼 내려가면 결과값 합산
4. dfs 에 확률값 곱해서 내려가기
5. 백트래킹을 통해 한 번 갔던 곳 다시 갈 수 있도록 함

### 🤔 후기

문제 이해하는데 한참 걸렸고 어떤 게 단순한 경우인 지 너무 헷갈렸음. 결국 단순한 경로라는 게 왔던 곳으로 다시 돌아오지 않는 경우라는 것이고 예를들어 1에서 동쪽으로 4번 가면 다시 돌아오니까 이 경로는 단순하지 않은 경로라는 얘기 였음 결국 다시 왔던 곳 돌아오지 않는 상황에서 N 만큼 이동했을 때 나오는 확률을 누적해서 더해주면 되는 문제 dfs + 델타 + 백트래킹의 전형적인 문제였음 아니 근데 문제 이해 너무 힘들게 해놨네..

## [가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)

### 💡 아이디어 / 접근법

1. dp 배열에 1로 채워서 현재값 수열에 넣었을 때 저장
2. 2중 for 문을 통해 현재값 보다 작은 값들 탐색
3. 작은 값들이 존재하면 dp 배열에 작은 값들의 수열에 현재 값 넣은 값과 현재 값의 수열 중 큰 값 저장
4. dp 배열에서 최대값 출력

### 🤔 후기

기본적인 LIS 문제인데 너무 어려웠음. 한 2~3시간 걸린 거 같은데 완벽히 이해가 아직도 안되는 부분이 있어서 내일 리뷰에서 얘기하고 싶어서 문제 풀이에 올렸음 도대체 왜 dp[i] 배열 저장할 때 dp[i] 값과 이전 값들의 수열에 하나를 넣은 값 중 최대값을 저장하는 지 이해가 안됨. 어차피 먼저 숫자 비교를 하고 들어오고 조건에 걸린 값들에 대해서만 수열에 넣어보면 되는 건데 dp[i] 값과 비교를 해야하는 지 정말 모르겠음 민성쓰 헬프...

## [가장 긴 감소하는 부분 수열](https://www.acmicpc.net/problem/11722)

### 💡 아이디어 / 접근법

1. dp 배열에 1로 채워서 현재값 수열에 넣었을 때 저장
2. 2중 for 문을 통해 현재값 보다 큰 값들 탐색
3. 큰 값들이 존재하면 dp 배열에 큰 값들의 수열에 현재 값 넣은 값과 현재 값의 수열 중 큰 값 저장
4. dp 배열에서 최대값 출력

### 🤔 후기

이 문제는 이전 문제에서 조건부만 다르게 하면 풀릴 거 같아서 했는데 맞았고 이 문제 역시도 완벽하게 이해는 못한 상황임.

## [전깃줄](https://www.acmicpc.net/problem/2565)

### 💡 아이디어 / 접근법

### 💡 아이디어 / 접근법

1. 입력값 왼쪽 값 기준으로 오름차순 정렬
2. dp 배열에 1로 채워서 오른쪽 값 수열에 넣었을 때 저장
3. 2중 for 문을 통해 현재값 보다 작은 값들 탐색
4. 작은 값들이 존재하면 dp 배열에 작은 값들의 수열에 현재 값 넣은 값과 현재 값의 수열 중 큰 값 저장
5. dp 배열에서 최대값 출력

### 🤔 후기

이 문제는 정렬 + LIS 문제라 해서 풀어봤는데 LIS 문제일 거라고 생각을 안했었는데 정렬을 한 번 해서 한 쪽 전봇대를 아예 생각을 안하고 풀면 돼서 좀 신박한 문제였음. 근데 이 문제 역시도 완벽하게 이해 못했음 ㅠ

---
