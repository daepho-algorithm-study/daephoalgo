|                     이번주 풀이 문제🧩                      |                                                            |                                                      |
| :---------------------------------------------------------: | :--------------------------------------------------------: | :--------------------------------------------------: |
| **1.** [하이퍼 토마토](https://www.acmicpc.net/problem/17114) | **2.** [가장 긴 증가하는 부분수열 2](https://www.acmicpc.net/problem/12015) | **3.** [가장 긴 증가하는 바이토닉 수열](https://www.acmicpc.net/problem/11054) |
|    **4.** [평범한 배낭](https://www.acmicpc.net/problem/12865)      |                                                |

# 🧩 문제

## [하이퍼 토마토](https://www.acmicpc.net/problem/17114)

### 💡 아이디어 / 접근법

1. 11 차원 배열 입력받기
2. 11차원 방향 벡터 설정
3. 11중 반복문 돌려서 0, 1 찾기
4. bfs 돌리면서 22번의 방향탐색 해서 최대값 찾기

### 🤔 후기

ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ
2시간 걸림

## [가장 긴 증가하는 부분수열 2](https://www.acmicpc.net/problem/12015)

### 💡 아이디어 / 접근법

1. 부분 수열에 처음 값 아무거나 넣기
2. 1부터 시작해서 배열 순회 돌리다가 만약 부분 수열의 마지막 값보다 arr[i] 의 값이 크면 부분수열에 집어 넣기
3. 부분수열의 마지막 값보다 작다면 현재 값을 넣어서 이진탐색 진행
4. 이진 탐색을 통해서 부분 수열에 있는 값들과 비교를 진행해서 작은 값이라면 최대한 왼쪽에 넣고 큰 값이라면 최대한 오른쪽에 넣도록 진행 후 마지막에 넣을 인덱스 값 반환
5. lis의 해당 인덱스 값을 arr[i] 로 할당
6. lis의 전체 길이 출력

### 🤔 후기

LIS 에서 이진 탐색을 넣은 버전인데, 처음에는 이진 탐색을 어떻게 이용할 수 있을 지 고민이 많았는데 LIS 배열은 항상 오름차순 정렬이 보장되기 때문에 2중 for 문을 통해 이전 값과 비교하는 부분을 이진 탐색으로 바꿔서 현재값이 수열에 들어갈 때 최적의 위치를 찾을 수 있도록 변경했다. LIS 문제가 확실히 재미는 있는 거 같은데 좀 많이 어려운 것 같다..


## [가장 긴 증가하는 부분 바이토닉 수열](https://www.acmicpc.net/problem/11054)

### 💡 아이디어 / 접근법

1. 정방향으로 LIS 구하기
2. 역방향으로 LDS 구하기
3. 두 가지 더한 값에서 -1 해준 값과 결과값 비교해서 최대값 갱신

### 🤔 후기
바이토닉 수열은 예를 들어서 1, 2, 3, 2, 1 처럼 특정한 인덱스를 기준으로 증가, 감소가 이루어지는 수열이라고 이해했다
그래서 일단 LIS + LDS 두 가지를 구했고 마지막에 겹치는 인덱스 -1 해주어 수열의 길이를 구했다. 마지막에 겹치는 index 생각 하지 않으면 조금 어려운 문제였다고 생각됐지만 LIS, LDS 를 알고 있는 상황에서 바이토닉 수열이 뭔지 알고 있으면 크게 어려운 문제는 아니었다고 생각함.

## [평범한 배낭](https://www.acmicpc.net/problem/12865)

### 💡 아이디어 / 접근법

1. 물건의 개수 만큼 반복문 돌리기
2. 무게와 값 뽑고
3. 뒤에서 부터 배낭에 넣어보고 값 할당하기
4. K 의 무게가 들어간 배낭 출력

### 🤔 후기

처음에는 앞에서 부터 배낭에 채워넣기를 진행했는데 풀다보니까 지금 이미 만든 배낭을 또 사용하는 경우가 발생하게 되었다 주석에 작성한 것 처럼 dp[2] 는 이미 있는 값인데 재사용하는 경우가 생기게 된다. 물론 다른 경우의 수를 살펴볼 때는 당연히 재사용해야하는 것이 하나의 물건과 다른 물건을 비교하는 부분에서 이미 넣었던 물건을 고려하면 안된다고 생각을 했고 그 부분을 해결하기 위해 뒤에서 부터 물건을 넣었다. DP 문제 진짜 너무 어렵다...

---
