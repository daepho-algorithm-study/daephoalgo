|                    이번주 풀이 문제🧩                    |                       |                         |
| :------------------------------------------------------: | :-------------------: | :---------------------: |
| **1.** [줄 세우기](https://www.acmicpc.net/problem/2252) | **2.** [문제집](https://www.acmicpc.net/problem/1766) | **3.** [최종순위](https://www.acmicpc.net/problem/3665) |

---

# 🧩 문제

## [줄 세우기](https://www.acmicpc.net/problem/2252)

### 💡 아이디어 / 접근법

1. 무향 그래프로 입력값 파싱하고 진입차수 배열에 카운팅
2. 정점 순회하면서 진입차수가 0인 경우 큐에 넣기
3. bfs 탐색으로 다음 값 뽑고 결과 배열에 저장
4. 다음 정점의 진입차수 줄이고 만약 다음 정점의 진입차수가 0이면 큐에 넣기

### 🤔 후기

위상정렬 문제를 처음 풀어봤는데 처음푸는 문제다 보니 개념부터 알아야 할 것 같아서 찾아보았음 처음에는 단순히 그래프 순회하면서 queue 에 넣고 다음 정점 넘어가보는 단순한 bfs 로 생각을 했었는데 그럼 시작점을 어떤 값으로 할 지 또 어떤 경우에 queue에 넣고 bfs를 진행할 지 몰랐었음 그래서 개념을 보니 진입 차수라는 배열이 나오고 해당 차수가 0인 경우에 다음 탐색을 진행 하는 방식으로 구현하는 거였음 실제 코드 구현은 어렵지 않게 했던 것 같음!

## [문제집](https://www.acmicpc.net/problem/1766)

### 💡 아이디어 / 접근법

1. 우선순위 큐 정의하고 그래프 파싱, 진입차수 배열에 카운팅
2. 정점 순회하면서 진입차수가 0인 경우 큐에 넣기
3. bfs 탐색으로 다음 값 뽑고 결과 배열에 저장
4. 다음 정점의 진입차수 줄이고 만약 다음 정점의 진입차수가 0이면 큐에 넣기

### 🤔 후기
 
해당 문제는 인덱스 값이 작은 값부터 위상정렬을 진행하여야 했는데 처음에는 단순하게 queue 를 한 번 오름차순으로 정렬하고 탐색을 시작하도록 했는데 그러면 반복문이 돌 때마다 추가 메모리를 생성하여 메모리 초과가 났음 그래서 어떻게 하면 좋을까 생각해보다가 우선순위 큐를 활용하기로 했음 그 중에서도 최소합을 사용해서 항상 가장 낮은 번호를 뽑을 수 있도록 했음 나머지 코드는 기본 위상정렬이랑 똑같음

## [최종순위](https://www.acmicpc.net/problem/3665)

### 💡 아이디어 / 접근법

1. 작년 순서 기준으로 그래프 만들고 진입차수에 나보다 뒤에 있는 값의 진입차수를 늘려줌
2. 그래프의 방향을 뒤집기
3. changes 배열을 순회하면서 바뀐 순위 뽑아오고 (a,b 라 가정) 만약 a의 앞에 b가 존재하면 b를 빼주고 b의 진입차수를 빼줌 a 에서 b 가 빠졌기 때문에 이제 a는 b보다 앞에 있지 않음 그래서 나보다 앞에 있는 팀의 수를 하나 줄여주기 위함
b에 a를 추가하고 a 가 b의 뒤로 이동했기 때문에 a의 나보다 앞에 있는 팀의 수를 하나 늘려줌
4. 반대의 경우도 마찬가지로 처리
5. 해당 그래프를 통해 위상정렬 수행
6. 만약 queue의 길이가 1보다 크다면 우열을 가릴 수 없기 때문에 ? 출력하고 break
7. 결과값의 길이가 N이 아니라면 사이클이 생겼다는 의미로 위상정렬이 불가능하다고 출력 아니라면 결과값 출력

### 🤔 후기
 
해당 문제는 그래프 파싱부터 진입차수 배열 생각하는 모든 게 어려웠던 문제였음 먼저 어느 정점의 진입차수를 늘려주려면 어떻게 해야할 지 감이 잘 오지 않았었는데 입력값을 잘 보니 반복문을 하나 더 돌리면 해결이 가능할 것 같아서 그렇게 진행했고 파싱은 잘 됐음 근데 이제 changes 배열로 실제 그래프에서 순위를 바꿔줘야 했는데 해당 문제는 2시간 이상 잡고 있었는데 해결이 안돼서 GPT의 도움을 살짝 받아보니 만약 정점에 바뀔 순위가 들어가 있으면 즉 정점 앞에 바뀔 순위가 존재하면 해당 순위를 빼주고 진입차수의 값을 하나 줄여주고 바뀔 순위의 정점에 현재 정점의 값을 넣어주고 진입차수의 값을 늘려주는 방식으로 하면 되더라 반대의 경우도 똑같이 처리하면 됐었음 그리고 마지막 문제가 어떤 경우에 ?, IMPOSSIBLE, result 를 반환하는 지 결정하는 문제 였는데 그 부분은 생각보다 쉽게 해결했다. 우리는 진입 차수가 0인 경우에 queue에 넣고 뽑아서 정렬을 진행하는 데 만약 큐가 [1,2] 두 개가 들어가면 어떤 정점부터 돌려야 하는 지 우열을 가릴 수 없다 따라서 queue의 길이가 1이 아니라면 ? 를 출력하면 되고 마지막 결과값의 길이가 N 보다 크다면 사이클이 한 번 이상은 발생했다는 의미다 즉 2 -> 3, 3 -> 2 처럼 말도 안되는 경우가 생긴 것이기 때문에 IMPOSSIBLE을 반환하고 아닌 경우에는 result를 반환하면 되는 문제였다.
