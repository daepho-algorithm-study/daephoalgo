|                    이번주 풀이 문제🧩                    |                                                           |                                                       |
| :------------------------------------------------------: | :-------------------------------------------------------: | :---------------------------------------------------: |
| **1.** [미로 탐색](https://www.acmicpc.net/problem/2178) |  **2.** [숨바꼭질](https://www.acmicpc.net/problem/1697)  | **3.** [토마토](https://www.acmicpc.net/problem/7569) |
|  **4.** [A -> B](https://www.acmicpc.net/problem/16953)  | **5.** [스타트링크](https://www.acmicpc.net/problem/5014) |  **6.** [숨바꼭질2](https://www.acmicpc.net/problem/12851) |                                                     |

# 🧩 문제

## [미로 탐색](https://www.acmicpc.net/problem/2178)

### 💡 아이디어 / 접근법

1. 최단 거리 탐색이므로 BFS 로 접근
2. 시작점은 0, 0 고정이기 때문에 별도로 받지 않고 BFS 내부의 queue에 정의 및 queue에 누적 거리 추가
3. queue에 다음 좌표와 dist 에 1씩 추가
4. 만약 해당 좌표가 N - 1, M - 1 이라면 dist 리턴

### 🤔 후기

문제 자체는 쉬웠음 저번에 풀었던 미로 탈출에 비하면 근데 백준에서 처음 node.js 로 풀어봤는데 입력값 처리가 좀 어지러웠음..

## [숨바꼭질](https://www.acmicpc.net/problem/1697)

### 💡 아이디어 / 접근법

1. 최단 거리 탐색이므로 BFS 로 접근
2. 시작점은 N 으로 주어지고 끝점도 K로 주어지므로 로직에 맞게 계속 좌표 누적한 뒤 현재 값이 K 일 경우 반환
3. 현재 위치에서 -1, +1, \*2의 값을 가지는 배열을 정의한 뒤 for 문을 통해 해당 좌표에 방문한 적이 있는 지 확인 그렇지 않다면 시간 누적과 함께 queue에 추가
4. queue에서 꺼낸 현재 위치가 만약 K 일 경우 시간 값 반환

### 🤔 후기

이 문제 자체도 2차원 배열이 아닐 뿐이지 BFS의 대표 문제라고 생각했음 근데 행동 반경이 델타가 아닌 -1, +1, \*2의 차이점이 있는

**3.** [토마토](https://www.acmicpc.net/problem/7569)

### 💡 아이디어 / 접근법

1. 3차원 배열 생성
2. 3차원 배열에서의 델타 탐색 + BFS 수행
3. 델타 탐색을 통한 다음 좌표 값이 만약 유효하다면 queue 에 저장하고 배열의 값 갱신
4. 3중 for 문을 통해 배열 순회한 뒤 max 값 갱신 만약 0이 존재한다면 익지 않은 토마토가 하나라도 존재한다는 의미이므로 -1 return

### 🤔 후기

처음에 3중으로 bfs 어떻게 하는 지 헤맸다... 그냥 평소와 똑같이 N, M, H 순으로 하려고 했는데 뭐가 자꾸 안되더라... H 가 먼저였어.. 그거 아니면 그냥 무난무난한 BFS 인거 같음

**4.** [A -> B](https://www.acmicpc.net/problem/16953)

### 💡 아이디어 / 접근법

1. 이거 그냥 숨바꼭질에서 계산 방법만 바뀐 거임
2. 계산이 -1, +1, *2 가 아니라 *2 혹은 오른쪽에 1 붙이기로 바뀜
3. 따라서 visited 자체도 필요 없음 왜 why? 어차피 짝수로 증가하기 때문에 오른쪽 끝에 1이 올 일이 없기 때문
4. 그렇게 해당값이 되면 cnt 리턴 못하면 -1 리턴

### 🤔 후기

그냥 쉬웠음..

**5.** [스타트링크](https://www.acmicpc.net/problem/5014)

### 💡 아이디어 / 접근법

1. 시작점을 S로 고정
2. BFS 를 통해 S 에서 U를 더할 건지 D를 뺄 건지 두 가지의 경우 정의
3. 시작점과 계산이 된 좌표 방문 체크
4. 목표층에 도달하면 시간 반환 그렇지 못하면 오류 문구 반환

### 🤔 후기

숨바꼭질 비슷한 시리즈로 BFS 감 잡기 하고 있는 중인데 아주 만족함..Good..

**6.** [숨바꼭질2](https://www.acmicpc.net/problem/12851)

### 💡 아이디어 / 접근법

1. 최단 거리 탐색이므로 BFS 로 접근
2. 시작점은 N 으로 주어지고 끝점도 K로 주어지므로 로직에 맞게 계속 좌표 누적한 뒤 현재 값이 K 일 경우 cnt에 +1 해주고 계속 진행
3. 시작점과 계산이 된 좌표 방문 체크 
4. 방문 체크할 때 boolean 값이 아닌 방문했을 때의 시간을 기록하여 해당 좌표에 다시 방문할 경우나 방문한 적이 아예 없는 경우 둘 다 고려 예를 들어 1에서 2까지 간다고 가정했을 때 visited[next[i]] 의 값이 next[i] 가 +1 인 경우를 먼저 보고 visited[next[i]] = 2가 기록이 됨 그 이후 진행을 하다 next[i] 의 값이 *2가 나왔을 경우를 봤을 때 visited[next[i]] === 2 이미 있는 상황임 따라서 두 가지의 경우가 cur + 1 인 경우가 생기기 때문에 중복 방문 처리를 해줘야 함
 

### 🤔 후기

숨바꼭질 비슷한 시리즈로 BFS 감 잡기 하고 있는 중인데 그 중 가장 어려웠던 문제였음 쉽게 생각해서 문제를 풀었는데 예외 케이스에 자꾸 걸려서 확인을 해보니 boolean 값으로 제한을 해버리면 다시 방문할 수 있는 경우를 고려하지 못하고 그렇다고 visited 자체를 없애 버리면 왔다갔다 하는 경우를 고려하지 못해서 고민을 많이 해본 문제였음.. 하지만 이 문제로 감이 조금씩 살아나고 있음!

---
