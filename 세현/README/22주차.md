# 이번주 풀이 문제🧩

| 번호  | 문제                                                                | 번호  | 문제                                           | 번호  | 문제                                        | 번호  | 문제                                                 |
| :---: | :------------------------------------------------------------------ | :---: | :--------------------------------------------- | :---: | :------------------------------------------ | :---: | :--------------------------------------------------- |
| **1** | [가장 긴 바이토닉 부분 수열](https://www.acmicpc.net/problem/11054) | **2** | [전깃줄](https://www.acmicpc.net/problem/2565) | **3** | [LCS](https://www.acmicpc.net/problem/9251) | **4** | [평범한 배낭](https://www.acmicpc.net/problem/12865) |

---

# 🧩 회고 문제

## [가장 긴 바이토닉 부분 수열](https://www.acmicpc.net/problem/11054)

### 💡 아이디어 / 접근법

- 최장증가수열 과 최장감소수열 을 섞어놓은 문제
- 각각 두 가지를 따로 구해서 결과를 합쳐야 함
- 최장 증가 수열을 i = 1 부터 시작해서 길이를 구하는 것은 동일
- 최장 감소 수열을 i = N-1 부터 거꾸로 오면서 최장 증가 수열처럼 길이를 구해줘야 함
- 예시로 1 5 2 1 4 3 4 5 2 1 이 있으면 최장 증가 수열은 그대로 구하고, 최장 감소 수열을 맨 마지막(1)에서 시작해서 하나씩 이동한 값(2)이 직전 값보다 크면 길이를 하나씩 더해주는 식으로 구해야 함
- 그렇게 해야 증가했다 감소하는 길이값을 온전히 구할 수 있음
- 둘 다 구했다면 증가, 감소 길이배열의 인덱스 순회하면서 둘을 더한 값-1 의 최댓값을 찾아주면 됨

### 🤔 후기

- 처음에 단순히 증가 수열, 감소 수열 따로 구해봤는데 겹치는 값을 어떻게 찾는지의 문제에 봉착함
- 풀이 처럼 최장 감소 수열을 거꾸로 구해주지 않아서 겹치는 값을 찾을 수 없었음
- 위 방법에 박혀버려서 시간을 많이 버렸던 문제였음..

---

## [전깃줄](https://www.acmicpc.net/problem/2565)

### 💡 아이디어 / 접근법

- 한쪽 전봇대를 기준으로 정렬시킴 (중요 중요)
- 한쪽 전봇대가 오름차순으로 정렬되어 있으면 반대 전봇대에서 최장 증가 수열(!!!) 길이를 구함
- 한 쪽을 정렬시키면 인덱스가 순차적으로 되어 있고 그 인덱스에 해당하는 값이 이전 인덱스의 값보다 작다면 전깃줄이 꼬인 형태가 되는 것임
- 전체 전깃줄 개수에서 최장 증가 수열 길이를 빼주면 최소 제거 수를 구할 수 있음

### 🤔 후기

- 저번에 설명 들었던거 같은데 기억이 안나서 한참 해맸음
- 포인트는 정렬과 최장 증가 수열 두가지였던 것
- 최장 증가 수열로 어떻게 하면 될거 같았는데 정렬해야 된다는 사실이 잘 안떠올랐음

---

## [LCS](https://www.acmicpc.net/problem/9251)

### 💡 아이디어 / 접근법

- 1 ~ N 개의 문자와 1 ~ M 개의 문자를 각각 비교해야 함
- 즉, N \* M 개의 배열을 생성하고 각 자리에(즉, 각 부분 수열에) 일치하는 문자의 최대 개수를 기록해야 함
- N ~ M 이중 포문 돌면서 각 문자가 같은지 확인
- 같다면 dp 배열에서 대각선 위의 dp 값[ i-1 ][ j-1 ]을 가져와서 +1 해줌
  - 이 말의 의미는 현재 str1의 i, str2의 j번째의 문자를 비교해서 같다면 이 문자를 str1 부분 수열, str2 부분 수열에 각각 추가해 주는 것임
- 다르다면 dp 배열에서 위쪽, 왼쪽 중 큰 값을 가져옴
  - 즉, str1의 이전 부분수열 최댓값과 str2의 이전 부분수열 최댓값 중 큰 값을 선택하는 것임

### 🤔 후기

- 이 문제는 감이 정말 안와서 Ai와 블로그를 참고함
- 이전 값의 최댓값을 어떻게 가져와야 하는지 많이 헷갈렸음
- dp 배열에서 왼쪽, 위와 대각선을 다 봐야해서 어려웠던 문제

---

## [평범한 배낭](https://www.acmicpc.net/problem/12865)

### 💡 아이디어 / 접근법

- 물건의 개수 _ 무게 (N _ K) 테이블을 만듬(dp 배열)
- 무게를 0부터(편의상) K 까지 돌면서 N의 i 번째 물건이 들어갈 지 말지를 결정해서 dp에 최댓값을 기록해나가는 문제
- i 번째 물건을 넣으면 i-1의 dp 값에서 i번째의 가치를 더해주면 되고 안넣는다면 i-1번째의 dp 값을 그대로 들고오면 됨
- 포인트는 dp 2차원 배열의 열 인덱스를 무게로 잡았기 때문에 물건의 무게를 인덱스와 계산한다는 점

### 🤔 후기

- 그리디 knapsack 문제랑 헷갈렸는데 이 문제는 무게와 가치를 나눌 수 있었던 점이 달랐음(그리디 방식으로 풀면 틀리더라)
- 무게를 인덱스로 활용해야 하는 점을 생각하는 게 어려웠음
- 인덱스 활용하는 좌표 압축 문제가 생각났음(방향은 다르지만)

---
