# 이번주 풀이 문제🧩

| 번호  | 문제                                              | 번호  | 문제                                                 | 번호  | 문제                                                           | 번호  | 문제                                                       |
| :---: | :------------------------------------------------ | :---: | :--------------------------------------------------- | :---: | :------------------------------------------------------------- | :---: | :--------------------------------------------------------- |
| **1** | [알고리즘 수업 - 피보나치 수 1](https://www.acmicpc.net/problem/24416) | **2** | [신나는 함수 실행](https://www.acmicpc.net/problem/9184) | **3** | [01타일](https://www.acmicpc.net/problem/1904)       | **4** | [파도반 수열](https://www.acmicpc.net/problem/9461) |
| **5** | [연속합](https://www.acmicpc.net/problem/1912)      | **6** | [RGB거리](https://www.acmicpc.net/problem/1149)     | **7** | [정수 삼각형](https://www.acmicpc.net/problem/1932)     | **8** | [계단 오르기](https://www.acmicpc.net/problem/2579)     |

---

# 🧩 회고 문제

## [신나는 함수 실행](https://www.acmicpc.net/problem/9184)

### 💡 아이디어 / 접근법

- 재귀식을 DP로 변환하는 문제
- 변수가 3개이므로 3차원 메모이제이션 배열을 생성
- 각 변수마다의 결과값을 기록해 둠
- 해당하는 기록이 있을 때 바로 반환해주기
- 기록이 없다면 재귀를 통해 계산해서 기록하기(기록하고 반환까지 꼭 해줘야 함)

### 🤔 후기

- 처음에 식을 해석하는데는 무리가 없었는데 구현 과정에서 애를 먹음
- 메모이제이션을 어떻게 굴리는지는 감이 왔는데 중간중간에 재귀를 어떻게 써야했는지 헷갈렸음
- 기록되어 있다면 그 값을 바로 리턴하고 기록이 안되어있으면 재귀를 돌면서 기록한다는 발상 까지 오래 걸림(처음에 재귀 안쓰고 구현해서 결과가 자꾸 undefined 나와 당황함)
- 재귀와 메모이제이션을 같이 써 본 적이 거의 없었던 것 같음(DP 자체를 풀어본 경험이 적음)
- 문제를 잘게 쪼개서 차근차근 짚어가는 사고 훈련이 더 필요하다고 느낌


---

## [연속합](https://www.acmicpc.net/problem/1912)

### 💡 아이디어 / 접근법

- 카데인 알고리즘
- 각각의 최대 부분합은 이전 최대 부분합이 반영된 결과값임
- 이전의 부분합이 음수로 나오면 그 값을 버리고 0부터 시작하는게 더 최적의 결과를 가져옴
- 이전 최대 부분합을 고려해서 스타팅 포인트를 옮긴다는 발상

### 🤔 후기

- 처음에 브루트 포스로 모든 값을 기록하려고 했었음
- 이 방식은 N이 10만일 때 연산을 50억번 해야해서 터짐
- 카데인 알고리즘이라는 생소한 개념을 익혔던 것 같음
- **연속된** 부분 수열 이라는 제약 조건에 해당하는 풀이법(최장 증가 부분 수열, 최장 공통 부분 수열과 다름)

---

## [RGB거리](https://www.acmicpc.net/problem/1149)

### 💡 아이디어 / 접근법

- 각각의 색을 칠하는 경우를 모두 기록해야 함

### 🤔 후기

- 처음에 메모이제이션 배열에다 해당 번째의 [최솟값, 인덱스] 형태로 기록하려고 했었음
- 그리고 최솟값 갱신해 나가다가 다음 인덱스가 겹치면 다음 배열에서 최솟값, 그다음 최솟값 차이와 현재 배열에서 최솟값, 그다음 최솟값의 차이가 작은 쪽을 수정하는 방식을 생각함
- 하지만 이 방식은 DP가 아니라 Greedy 방식이었음 (결정을 번복하는 것)
- 메모이제이션은 기록된 값을 바로 들고오는 것인데 이 점을 망각했었음
- 각각의 색을 칠하는 경우를 모두 기록해 놓으면 이전 단계에서 그 색깔로 끝났을 때의 최상의 결과가 반영되어 있기 때문에 그냥 꺼내 쓰면 되는 것임
---

## [계단 오르기](https://www.acmicpc.net/problem/2579)

### 💡 아이디어 / 접근법

- 계단을 오르는 두 가지 방법을 고려
    - 두 칸을 뛰어서(n-2) n번째 계단에 도착 
    - 직전 칸을 밟고(n-1) n번째 계단에 도착
- 여기서 두 번째 경우 직전 칸을 밟기 위해서는 무조건 이전에 n-3 번째 계단을 밟았어야 함
- f(n) = [f(n-3) + n-1번째 계단 + n번째 계단 , f(n-2) + n번째 계단]

### 🤔 후기

- 이번에는 차근차근 생각해 냈던 것 같음
- 한 칸만 뛰면 그 다음은 무조건 두 번 뛰어야 한다는 제약조건을 생각하면서 추리해 나갔던게 주요했음
- 결과적으로 n-1, n-2 가 아니라 n-2, n-3을 설정 하고 풀어 나갈 수 있었음
- 문제를 어떻게 쪼개야 하는지를 많이 연습해야 할 필요성을 느낌

---
